#!/system/bin/sh
# L Speed tweak
# Codename : lspeed
version="v1.6";
build_date=1-1-2020;
# Developer : Paget96
# Paypal : https://paypal.me/Paget96

# To select current profile go to /data/lspeed/setup
# and edit file "profile"
# 0 - default
# 1 - power saving
# 2 - balanced
# 3 - performance
# Save the file and reboot phone
#
# To check if mod working go to /data/lspeed/log/main_log.log
# that's main output after executing lspeed.sh
#

########
#PATHS #
########
# Path where logs and setup is stored
LSPEED_DATA_DIR=/data/lspeed
LOG_DIR=$LSPEED_DATA_DIR/log
LOG=$LOG_DIR/main_log.log

# Setup paths
SETUP_DIR=$LSPEED_DATA_DIR/setup
USER_PROFILE=$SETUP_DIR/user_profile
PROFILE=$SETUP_DIR/profile

# Path for executables and busybox
LSPEED=/system/etc/lspeed
BINARY_DIR=$LSPEED/binary
BUSYBOX=$BINARY_DIR/busybox
CPU_DETECT=$BINARY_DIR/cpu_detect
CPUSET_TUNER=$BINARY_DIR/cpuset_tuner

# cpu_detect output files
CPU_DETECT_DATA_DIR=$SETUP_DIR/cpu_detect
CPU_CORE_COUNT=$CPU_DETECT_DATA_DIR/cpu_core_count
REAL_CPU_CORE_COUNT=$CPU_DETECT_DATA_DIR/real_cpu_core_count
MIN_MAX_FREQ=$CPU_DETECT_DATA_DIR/min_max_freq
MIN_FREQ_LIST=$CPU_DETECT_DATA_DIR/min_freq_list
MAX_FREQ_LIST=$CPU_DETECT_DATA_DIR/max_freq_list
LOGICAL_CORE=$CPU_DETECT_DATA_DIR/logical_core
UNIQUE_FREQ=$CPU_DETECT_DATA_DIR/unique_freq
CORE_GETTER=$CPU_DETECT_DATA_DIR/core_getter

# Variables
memTotal=$($BUSYBOX free -m | $BUSYBOX awk '/^Mem:/{print $2}');
# Prevent issues when $memTotal return weird output (including non-integer values, empty strings...),
# in this case device acts like a 4GB RAM device
case $memTotal in
    ''|*[!0-9]*) memTotal=4096 ;;
    *) memTotal=$memTotal ;;
esac

abi=$($BUSYBOX grep /system/build.prop ro.product.cpu.abi | $BUSYBOX head -n1 | $BUSYBOX cut -d= -f2);
case $abi in
    arm*|x86*) ;;
    *) abi=$(getprop ro.product.cpu.abi);;
esac;
case $abi in
    arm*|x86*) ;;
    *) abi=$($BUSYBOX grep /system/default.prop ro.product.cpu.abi | $BUSYBOX head -n1 | $BUSYBOX cut -d= -f2);
esac;
case $abi in
    arm64*) arch=arm64;;
    arm*) arch=arm;;
    x86_64*) arch=x86_64;;
    x86*) arch=x86;;
    *) arch="Unknown arch: $abi";;
esac;

real_cpu_cores=$($BUSYBOX ls /sys/devices/system/cpu | $BUSYBOX grep -c ^cpu[0-9]);
cpu_cores=$((real_cpu_cores-1));
brand=$(getprop ro.product.brand) 2>/dev/null
model=$(getprop ro.product.model) 2>/dev/null
rom=$(getprop ro.build.display.id) 2>/dev/null
androidRelease=$(getprop ro.build.version.release) 2>/dev/null
api=$(getprop ro.build.version.sdk) 2>/dev/null
kernel=$(uname -r) 2>/dev/null
root=$(magisk -c) 2>/dev/null
divider="==============================================="

# Detecting modules path
if [ -d /data/adb/modules ]; then
	MODULES=/data/adb/modules
elif [ -d /sbin/.core/img ]; then
	MODULES=/sbin/.core/img
elif [ -d /sbin/.magisk/img ]; then
	MODULES=/sbin/.magisk/img
fi;

# Functions
createFile() {
    touch "$1"
    chmod 0666 "$1"
}

sendToLog() {
timeZone=$(getprop persist.sys.timezone)
printDate=$(TZ="$timeZone" $BUSYBOX date +"%H:%M:%S:%3N %d-%m-%Y")

echo "[$printDate] $1" >> $LOG
}

write() {
	#chmod 0644 "$1"
    echo "$2" > "$1"
}

lockFile() {
	chmod 0644 "$1"
    echo "$2" > "$1"
	chmod 0444 "$1"
}

getScheduler() {
	echo "$($BUSYBOX cut -d [ -f2 "$1"/queue/scheduler | $BUSYBOX cut -d] -f1)"
}

# Setting up the main path where are logs and setup is stored
# If for any reason any of them are missing, add them manually
if [ ! -d $LSPEED_DATA_DIR ]; then
	mkdir -p $LSPEED_DATA_DIR
fi;

# Create log directory if doesn't exists
# All the logs will be placed here
if [ ! -d $LOG_DIR ]; then
	mkdir -p $LOG_DIR
fi;

# Remove old logs when running the script again
# and create dir if not exists
# This will be only executed if there are no arguments while executing
if [ "$#" -eq 0 ]; then
	if [ -e $LOG ]; then
		rm -rf $LOG
	fi;
fi;

# Create setup dir and child files and dirs
# Needed for module working at all
# /data/lsepeed/setup/profile
# /data/lsepeed/setup/user_profile/*
if [ ! -d $SETUP_DIR ]; then
	mkdir -p $SETUP_DIR
fi;

# Create $PROFILE file if not exists
if [ ! -f $PROFILE ]; then
	createFile $PROFILE
fi;

# Directory dedicated for storing current profile
if [ ! -d $USER_PROFILE ]; then
	mkdir -p $USER_PROFILE
fi;

# Store the PID
write $LSPEED_DATA_DIR/main_function_PID $$

# Create controllers
# This will be used for the Manager to take a control over the module
if [ -d $USER_PROFILE ]; then
	createFile $USER_PROFILE/battery_improvements
	createFile $USER_PROFILE/doze_optimization

	# CPU section
	createFile $USER_PROFILE/cpu_optimization
	createFile $USER_PROFILE/governor_tuner

	createFile $USER_PROFILE/entropy

	# GPU section
	createFile $USER_PROFILE/gpu_optimizer
	createFile $USER_PROFILE/optimize_buffers
	createFile $USER_PROFILE/render_opengles_using_gpu
	createFile $USER_PROFILE/use_opengl_skia
	createFile $USER_PROFILE/force_gpu_rendering
	createFile $USER_PROFILE/force_4x_msaa

	# I/O tweaks section
	createFile $USER_PROFILE/disable_io_stats
	createFile $USER_PROFILE/io_blocks_optimization
	createFile $USER_PROFILE/io_extended_queue
	createFile $USER_PROFILE/scheduler_tuner
	createFile $USER_PROFILE/sd_tweak

	# LNET tweaks section
	createFile $USER_PROFILE/dns
	createFile $USER_PROFILE/net_buffers
	createFile $USER_PROFILE/net_speed_plus
	createFile $USER_PROFILE/net_tcp
	createFile $USER_PROFILE/optimize_ril

	# Other
	createFile $USER_PROFILE/disable_debugging
	createFile $USER_PROFILE/disable_kernel_panic
	createFile $USER_PROFILE/selinux

	# RAM manager section
	createFile $USER_PROFILE/ram_manager
	createFile $USER_PROFILE/disable_multitasking_limitations
	createFile $USER_PROFILE/low_ram_flag
	createFile $USER_PROFILE/oom_killer
	createFile $USER_PROFILE/swappiness
	createFile $USER_PROFILE/virtual_memory
	createFile $USER_PROFILE/heap_optimization

fi;

# Get device info when starting the module. 
# this will be done only on boot or executed service with sh over terminal
if [ "$#" -eq 0 ] || [ ! -e $LOG ]; then
	sendToLog "L Speed finished with base setup";

	sendToLog "Starting with logging...";
	sendToLog $divider;
	sendToLog "Getting module info"
	sendToLog "Version: $version ($build_date)";
	sendToLog $divider;
	sendToLog "Getting device info"
	sendToLog "Brand: $brand"
	sendToLog "Model: $model"
	sendToLog "Arch: $arch"
	sendToLog "ROM: $rom (Android: $androidRelease|API: $api)"
	sendToLog "Kernel: $kernel"
	sendToLog "Root: $root"
	sendToLog "RAM: $((memTotal))mb"
	sendToLog $divider;
fi

#
# Battery improvements
#
batteryImprovements() {
sendToLog "Activating battery improvements...";

	# Disabling ksm
	if [ -e "/sys/kernel/mm/ksm/run" ]; then
		write /sys/kernel/mm/ksm/run "0";
		sendToLog "KSM is disabled, saving battery cycles and improving battery life...";
	fi;

	# Disabling uksm
	if [ -e "/sys/kernel/mm/uksm/run" ]; then
		write /sys/kernel/mm/uksm/run "0"
		sendToLog "UKSM is disabled, saving battery cycles and improving battery life...";
	fi;

	# Kernel sleepers
	if [ -e "/sys/kernel/sched/gentle_fair_sleepers" ]; then
		write /sys/kernel/sched/gentle_fair_sleepers "0"
		sendToLog "Gentle fair sleepers disabled...";
	fi;

	if [ -e "/sys/kernel/sched/arch_power" ]; then
		write /sys/kernel/sched/arch_power "1"
		sendToLog "Arch power enabled...";
	fi;

	if [ -e "/sys/kernel/debug/sched_features" ]; then
		# Only give sleepers 50% of their service deficit. This allows
		# them to run sooner, but does not allow tons of sleepers to
		# rip the spread apart.
		write /sys/kernel/debug/sched_features "NO_GENTLE_FAIR_SLEEPERS"
		sendToLog "GENTLE_FAIR_SLEEPERS disabled...";

		write /sys/kernel/debug/sched_features "ARCH_POWER"
		sendToLog "ARCH_POWER enabled...";
	fi;

	# Enable fast charging
	if [ -e "/sys/kernel/fast_charge/force_fast_charge" ];  then
		write /sys/kernel/fast_charge/force_fast_charge "1"
		sendToLog "Fast charge enabled";
	fi;

	resetprop ro.audio.flinger_standbytime_ms 300
	sendToLog "Set low audio flinger standby delay to 300ms for reducing power consumption";

	scsi_disk=$($BUSYBOX ls -d /sys/class/scsi_disk/*) 2>/dev/null
	for i in $scsi_disk; do
 		write "$i"/cache_type "temporary none"
 		sendToLog "Set cache type to temporary none in $i";
 	done

	if [ -e /sys/module/wakeup/parameters/enable_bluetooth_timer ]; then
		write /sys/module/wakeup/parameters/enable_bluetooth_timer "Y"
		write /sys/module/wakeup/parameters/enable_ipa_ws "N"
		write /sys/module/wakeup/parameters/enable_netlink_ws "Y"
		write /sys/module/wakeup/parameters/enable_netmgr_wl_ws "Y"
		write /sys/module/wakeup/parameters/enable_qcom_rx_wakelock_ws "N"
		write /sys/module/wakeup/parameters/enable_timerfd_ws "Y"
		write /sys/module/wakeup/parameters/enable_wlan_extscan_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_wow_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_ws "N"
		write /sys/module/wakeup/parameters/enable_netmgr_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_wow_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_ipa_ws "N"
		write /sys/module/wakeup/parameters/enable_wlan_pno_wl_ws "N"
		write /sys/module/wakeup/parameters/enable_wcnss_filter_lock_ws "N"
		sendToLog "Blocked various wakelocks";
	fi;

	if [ -e /sys/module/bcmdhd/parameters/wlrx_divide ]; then
		write /sys/module/bcmdhd/parameters/wlrx_divide "4"
		write /sys/module/bcmdhd/parameters/wlctrl_divide "4"
		sendToLog "wlan wakelocks blocked";
	fi;

	if [ -e /sys/devices/virtual/misc/boeffla_wakelock_blocker/wakelock_blocker ]; then
		write /sys/devices/virtual/misc/boeffla_wakelock_blocker/wakelock_blocker "wlan_pno_wl;wlan_ipa;wcnss_filter_lock;hal_bluetooth_lock;IPA_WS;sensor_ind;wlan;netmgr_wl;qcom_rx_wakelock;wlan_wow_wl;wlan_extscan_wl;NETLINK;bam_dmux_wakelock;IPA_RM12"
		sendToLog "Updated Boeffla wakelock blocker";

	elif [ -e /sys/class/misc/boeffla_wakelock_blocker/wakelock_blocker ]; then
		write /sys/class/misc/boeffla_wakelock_blocker/wakelock_blocker "wlan_pno_wl;wlan_ipa;wcnss_filter_lock;hal_bluetooth_lock;IPA_WS;sensor_ind;wlan;netmgr_wl;qcom_rx_wakelock;wlan_wow_wl;wlan_extscan_wl;NETLINK;bam_dmux_wakelock;IPA_RM12"
		sendToLog "Updated Boeffla wakelock blocker";
	fi;

	# lpm Levels
	lpm=/sys/module/lpm_levels
	if [ -d $lpm/parameters ]; then
		write $lpm/enable_low_power/l2 "4"
		write $lpm/parameters/lpm_prediction "Y"
		write $lpm/parameters/menu_select "N"
		write $lpm/parameters/print_parsed_dt "N"
		write $lpm/parameters/sleep_disabled "N"
		write $lpm/parameters/sleep_time_override "0"
		sendToLog "Low power mode sleep enabled";
	fi;

	if [ -e "/sys/class/lcd/panel/power_reduce" ]; then
		write /sys/class/lcd/panel/power_reduce "1"
		sendToLog "LCD power reduce enabled";
	fi;

	if [ -e "/sys/module/pm2/parameters/idle_sleep_mode" ]; then
		write /sys/module/pm2/parameters/idle_sleep_mode "Y"
		sendToLog "PM2 module idle sleep mode enabled";
	fi;

	sendToLog "Battery improvements are enabled";
	sendToLog "$divider";
}

#
# Doze optimization
#
dozeOptimization() {

	if [ "$api" -ge 23 ]; then
		if [ "$1" = "1" ]; then
			sendToLog "Enabling doze optimization";

			# Get lockScreen timeout value to delay enter doze and avoid not locking device
			lockScreenTimeout=$(settings get secure lock_screen_lock_after_timeout)
			
			case $lockScreenTimeout in
				''|*[!0-9]*) lockScreenTimeout=5000 ;;
				*) lockScreenTimeout=$lockScreenTimeout ;;
			esac
			
			if [ $lockScreenTimeout -eq 0 ]; then 
				lockScreenTimeout=$((lockScreenTimeout+1000))
			fi

			lightDozeTimeout=$lockScreenTimeout
			deepDozeTimeout=$((lockScreenTimeout+20000))

			lightAfterInactiveTo=$lightDozeTimeout
			lightPreIdleTo="60000"
			lightIdleTo="180000"
			lightIdleFactor="2.0"
			lightMaxIdleTo="240000"
			lightIdleMaintenanceMinBudget="60000"
			lightIdleMaintenanceMaxBudget="180000"
			minLightMaintenanceTime="5000"
			minDeepMaintenanceTime="30000"
			inactiveTo=$deepDozeTimeout
			sensingTo="0"
			locatingTo="0"
			locationAccuracy="20.0"
			motionInactiveTo="0"
			idleAfterInactiveTo="0"
			idlePendingTo="60000"
			maxIdlePendingTo="120000"
			idlePendingFactor="2.0"
			idleTo="900000"
			maxIdleTo="21600000"
			idleFactor="2.0"
			minTimeToAlarm="600000"
			maxTempAppWhitelistDuration="10000"
			mmsTempAppWhitelistDuration="10000"
			smsTempAppWhitelistDuration="10000"
			notificationWhitelistDuration="30000"

			if [ "$api" -gt 23 ]; then
				parameters="inactive_to=$inactiveTo,sensing_to=$sensingTo,locating_to=$locatingTo,location_accuracy=$locationAccuracy,motion_inactive_to=$motionInactiveTo,idle_after_inactive_to=$idleAfterInactiveTo,idle_pending_to=$idlePendingTo,max_idle_pending_to=$maxIdlePendingTo,idle_pending_factor=$idlePendingFactor,idle_to=$idleTo,max_idle_to=$maxIdleTo,idle_factor=$idleFactor,min_time_to_alarm=$minTimeToAlarm,max_temp_app_whitelist_duration=$maxTempAppWhitelistDuration,mms_temp_app_whitelist_duration=$mmsTempAppWhitelistDuration,sms_temp_app_whitelist_duration=$smsTempAppWhitelistDuration,light_after_inactive_to=$lightAfterInactiveTo,light_pre_idle_to=$lightPreIdleTo,light_idle_to=$lightIdleTo,light_idle_factor=$lightIdleFactor,light_max_idle_to=$lightMaxIdleTo,light_idle_maintenance_min_budget=$lightIdleMaintenanceMinBudget,light_idle_maintenance_max_budget=$lightIdleMaintenanceMaxBudget,min_light_maintenance_time=$minLightMaintenanceTime,min_deep_maintenance_time=$minDeepMaintenanceTime,notification_whitelist_duration=$notificationWhitelistDuration"
			else
				parameters="inactive_to=$inactiveTo,sensing_to=$sensingTo,locating_to=$locatingTo,location_accuracy=$locationAccuracy,motion_inactive_to=$motionInactiveTo,idle_after_inactive_to=$idleAfterInactiveTo,idle_pending_to=$idlePendingTo,max_idle_pending_to=$maxIdlePendingTo,idle_pending_factor=$idlePendingFactor,idle_to=$idleTo,max_idle_to=$maxIdleTo,idle_factor=$idleFactor,min_time_to_alarm=$minTimeToAlarm,max_temp_app_whitelist_duration=$maxTempAppWhitelistDuration,mms_temp_app_whitelist_duration=$mmsTempAppWhitelistDuration,sms_temp_app_whitelist_duration=$smsTempAppWhitelistDuration"
			fi

			settings put global device_idle_constants $parameters

			sendToLog "device_idle_constants=$parameters";
			sendToLog "Doze optimization enabled";
		elif [ "$1" = "0" ]; then

			sendToLog "Doze optimization disabled";
		fi
	else
		sendToLog "Your device don't support doze";
	fi

	sendToLog "$divider";
}

#
# CPU Optimization battery profile
#
cpuOptimizationBattery() {
	sendToLog "Applying power saving CPU optimization...";

	if [ -e "/sys/devices/system/cpu/cpuidle/use_deepest_state" ]; then
		write /sys/devices/system/cpu/cpuidle/use_deepest_state "1"
		sendToLog "Enable deepest CPU idle state";
	fi;

	# Disable krait voltage boost
	if [ -e "/sys/module/acpuclock_krait/parameters/boost" ];  then
		write /sys/module/acpuclock_krait/parameters/boost "N"
		sendToLog "Disable Krait voltage boost";
	fi;

	if [ -e "/sys/module/workqueue/parameters/power_efficient" ]; then
		lockFile /sys/module/workqueue/parameters/power_efficient "Y"
		sendToLog "Power-save workqueues enabled, scheduling workqueues on awake CPUs to save power."
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/input_boost_duration ]; then
		write /sys/module/cpu_input_boost/parameters/input_boost_duration "0"
		sendToLog "CPU Boost Input Duration=0"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms "0"
		sendToLog "CPU Boost Input Ms=0"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms_s2 ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms_s2 "0"
		sendToLog "CPU Boost Input Ms_S2=0"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_boost/parameters/dynamic_stune_boost "0"
		sendToLog "CPU Boost Dyn_Stune_Boost=0"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/dynamic_stune_boost "0"
		sendToLog "CPU input boost Dyn_Stune_Boost=0"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/general_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/general_stune_boost "10"
		sendToLog "CPU input boost General_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_boost_duration ]; then
		write /sys/module/dsboost/parameters/input_boost_duration "0"
		sendToLog "Dsboost Input Boost Duration=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_stune_boost ]; then
		write /sys/module/dsboost/parameters/input_stune_boost "0"
		sendToLog "Dsboost Input Stune Boost Duration=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/sched_stune_boost ]; then
		write /sys/module/dsboost/parameters/sched_stune_boost "0"
		sendToLog "Dsboost Sched_Stune_Boost=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_boost_duration ]; then
		write /sys/module/dsboost/parameters/cooldown_boost_duration "0"
		sendToLog "Dsboost Cooldown_Boost_Duration=0"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_stune_boost ]; then
		write /sys/module/dsboost/parameters/cooldown_stune_boost "0"
		sendToLog "Dsboost Cooldown_Stune_Boost=0"
	fi;

	# CPU CTL
	if [ -e /dev/cpuctl/cpu.rt_period_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "1000000"
		sendToLog "cpu.rt_period_us=1000000"
	fi;

	if [ -e /dev/cpuctl/cpu.rt_runtime_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "950000"
		sendToLog "cpu.rt_runtime_us=950000"
	fi;

	sched_rt_period_us=/proc/sys/kernel/sched_rt_period_us
	if [ -e $sched_rt_period_us ]; then
		write $sched_rt_period_us "1000000"
		sendToLog "$sched_rt_period_us=1000000"
	fi;

	sched_rt_runtime_us=/proc/sys/kernel/sched_rt_runtime_us
	if [ -e $sched_rt_runtime_us ]; then
		write $sched_rt_runtime_us "950000"
		sendToLog "$sched_rt_runtime_us=950000"
	fi;

	sched_wake_to_idle=/proc/sys/kernel/sched_wake_to_idle
	if [ -e $sched_wake_to_idle ]; then
		write $sched_wake_to_idle "0"
		sendToLog "$sched_wake_to_idle=0"
	fi;

	# Disable touch boost
	touchboost=/sys/module/msm_performance/parameters/touchboost
	if [ -e $touchboost ]; then
		write $touchboost "0"
		sendToLog "$touchboost=0"
	fi;

	touch_boost=/sys/power/pnpmgr/touch_boost
	if [ -e $touch_boost ]; then
		write $touch_boost "N"
		sendToLog "$touch_boost=N"
	fi;

	#Disable CPU Boost
	boost_ms=/sys/module/cpu_boost/parameters/boost_ms
	if [ -e $boost_ms ]; then
		write $boost_ms "N"
		sendToLog "$boost_ms=N"
	fi;

	sched_boost_on_input=/sys/module/cpu_boost/parameters/sched_boost_on_input
	if [ -e $sched_boost_on_input ]; then
		write $sched_boost_on_input "N"
		sendToLog "$sched_boost_on_input=N"
	fi;
	
	sh $CPUSET_TUNER 1

	sendToLog "Power saving CPU optimization applied";
	sendToLog "$divider";
}

#
# CPU Optimization balanced profile
#
cpuOptimizationBalanced() {
	sendToLog "Applying balanced CPU optimization...";
		
	if [ -e "/sys/devices/system/cpu/cpuidle/use_deepest_state" ]; then
		write /sys/devices/system/cpu/cpuidle/use_deepest_state "1"
		sendToLog "Enable deepest CPU idle state";
	fi;

	# Disable krait voltage boost
	if [ -e "/sys/module/acpuclock_krait/parameters/boost" ];  then
		write /sys/module/acpuclock_krait/parameters/boost "N"
		sendToLog "Disable Krait voltage boost";
	fi;

	if [ -e "/sys/module/workqueue/parameters/power_efficient" ]; then
		lockFile /sys/module/workqueue/parameters/power_efficient "N"
		sendToLog "Power-save workqueues disabled, scheduling workqueues on awake CPUs to save power."
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/input_boost_duration ]; then
		write /sys/module/cpu_input_boost/parameters/input_boost_duration "60"
		sendToLog "CPU Boost Input Duration=60"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms "60"
		sendToLog "CPU Boost Input Ms=60"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms_s2 ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms_s2 "30"
		sendToLog "CPU Boost Input Ms_S2=30"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_boost/parameters/dynamic_stune_boost "20"
		sendToLog "CPU Boost Dyn_Stune_Boost=20"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/dynamic_stune_boost "20"
		sendToLog "CPU input boost Dyn_Stune_Boost=20"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/general_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/general_stune_boost "60"
		sendToLog "CPU input boost General_Stune_Boost=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_boost_duration ]; then
		write /sys/module/dsboost/parameters/input_boost_duration "60"
		sendToLog "Dsboost Input Boost Duration=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_stune_boost ]; then
		write /sys/module/dsboost/parameters/input_stune_boost "60"
		sendToLog "Dsboost Input Stune Boost Duration=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/sched_stune_boost ]; then
		write /sys/module/dsboost/parameters/sched_stune_boost "10"
		sendToLog "Dsboost Sched_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_boost_duration ]; then
		write /sys/module/dsboost/parameters/cooldown_boost_duration "60"
		sendToLog "Dsboost Cooldown_Boost_Duration=60"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_stune_boost ]; then
		write /sys/module/dsboost/parameters/cooldown_stune_boost "10"
		sendToLog "Dsboost Cooldown_Stune_Boost=10"
	fi;

	# CPU CTL
	if [ -e /dev/cpuctl/cpu.rt_period_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "1000000"
		sendToLog "cpu.rt_period_us=1000000"
	fi;

	if [ -e /dev/cpuctl/cpu.rt_runtime_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "950000"
		sendToLog "cpu.rt_runtime_us=950000"
	fi;

	sched_rt_period_us=/proc/sys/kernel/sched_rt_period_us
	if [ -e $sched_rt_period_us ]; then
		write $sched_rt_period_us "1000000"
		sendToLog "$sched_rt_period_us=1000000"
	fi;

	sched_rt_runtime_us=/proc/sys/kernel/sched_rt_runtime_us
	if [ -e $sched_rt_runtime_us ]; then
		write $sched_rt_runtime_us "950000"
		sendToLog "$sched_rt_runtime_us=950000"
	fi;

	sched_wake_to_idle=/proc/sys/kernel/sched_wake_to_idle
	if [ -e $sched_wake_to_idle ]; then
		write $sched_wake_to_idle "0"
		sendToLog "$sched_wake_to_idle=0"
	fi;

	# Disable touch boost
	touchboost=/sys/module/msm_performance/parameters/touchboost
	if [ -e $touchboost ]; then
		write $touchboost "0"
		sendToLog "$touchboost=0"
	fi;

	touch_boost=/sys/power/pnpmgr/touch_boost
	if [ -e $touch_boost ]; then
		write $touch_boost "N"
		sendToLog "$touch_boost=N"
	fi;

	#Disable CPU Boost
	boost_ms=/sys/module/cpu_boost/parameters/boost_ms
	if [ -e $boost_ms ]; then
		write $boost_ms "N"
		sendToLog "$boost_ms=N"
	fi;

	sched_boost_on_input=/sys/module/cpu_boost/parameters/sched_boost_on_input
	if [ -e $sched_boost_on_input ]; then
		write $sched_boost_on_input "N"
		sendToLog "$sched_boost_on_input=N"
	fi;
	
	sh $CPUSET_TUNER 2

	sendToLog "Balanced CPU optimization applied";
	sendToLog "$divider";
}

#
# CPU Optimization performance profile
#
cpuOptimizationPerformance() {
	sendToLog "Applying performance CPU optimization...";

	if [ -e "/sys/devices/system/cpu/cpuidle/use_deepest_state" ]; then
		write /sys/devices/system/cpu/cpuidle/use_deepest_state "1"
		sendToLog "Enable deepest CPU idle state";
	fi;

	# Disable krait voltage boost
	if [ -e "/sys/module/acpuclock_krait/parameters/boost" ];  then
		write /sys/module/acpuclock_krait/parameters/boost "Y"
		sendToLog "Enable Krait voltage boost";
	fi;

	if [ -e "/sys/module/workqueue/parameters/power_efficient" ]; then
		lockFile /sys/module/workqueue/parameters/power_efficient "N"
		sendToLog "Power-save workqueues disabled, scheduling workqueues on awake CPUs to save power."
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/input_boost_duration ]; then
		write /sys/module/cpu_input_boost/parameters/input_boost_duration "120"
		sendToLog "CPU Boost Input Duration=120"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms "120"
		sendToLog "CPU Boost Input Ms=120"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/input_boost_ms_s2 ]; then
		write /sys/module/cpu_boost/parameters/input_boost_ms_s2 "50"
		sendToLog "CPU Boost Input Ms_S2=50"
	fi;

	if [ -e /sys/module/cpu_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_boost/parameters/dynamic_stune_boost "30"
		sendToLog "CPU Boost Dyn_Stune_Boost=30"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/dynamic_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/dynamic_stune_boost "30"
		sendToLog "CPU input boost Dyn_Stune_Boost=30"
	fi;

	if [ -e /sys/module/cpu_input_boost/parameters/general_stune_boost ]; then
		write /sys/module/cpu_input_boost/parameters/general_stune_boost "10"
		sendToLog "CPU input boost General_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_boost_duration ]; then
		write /sys/module/dsboost/parameters/input_boost_duration "120"
		sendToLog "Dsboost Input Boost Duration=120"
	fi;

	if [ -e /sys/module/dsboost/parameters/input_stune_boost ]; then
		write /sys/module/dsboost/parameters/input_stune_boost "120"
		sendToLog "Dsboost Input Stune Boost Duration=120"
	fi;

	if [ -e /sys/module/dsboost/parameters/sched_stune_boost ]; then
		write /sys/module/dsboost/parameters/sched_stune_boost "10"
		sendToLog "Dsboost Sched_Stune_Boost=10"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_boost_duration ]; then
		write /sys/module/dsboost/parameters/cooldown_boost_duration "120"
		sendToLog "Dsboost Cooldown_Boost_Duration=120"
	fi;

	if [ -e /sys/module/dsboost/parameters/cooldown_stune_boost ]; then
		write /sys/module/dsboost/parameters/cooldown_stune_boost "10"
		sendToLog "Dsboost Cooldown_Stune_Boost=10"
	fi;

	# CPU CTL
	if [ -e /dev/cpuctl/cpu.rt_period_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "1000000"
		sendToLog "cpu.rt_period_us=1000000"
	fi;

	if [ -e /dev/cpuctl/cpu.rt_runtime_us ]; then
		write /dev/cpuctl/cpu.rt_period_us "950000"
		sendToLog "cpu.rt_runtime_us=950000"
	fi;

	sched_rt_period_us=/proc/sys/kernel/sched_rt_period_us
	if [ -e $sched_rt_period_us ]; then
		write $sched_rt_period_us "1000000"
		sendToLog "$sched_rt_period_us=1000000"
	fi;

	sched_rt_runtime_us=/proc/sys/kernel/sched_rt_runtime_us
	if [ -e $sched_rt_runtime_us ]; then
		write $sched_rt_runtime_us "950000"
		sendToLog "$sched_rt_runtime_us=950000"
	fi;


	sched_wake_to_idle=/proc/sys/kernel/sched_wake_to_idle
	if [ -e $sched_wake_to_idle ]; then
		write $sched_wake_to_idle "0"
		sendToLog "$sched_wake_to_idle=0"
	fi;

	# Disable touch boost
	touchboost=/sys/module/msm_performance/parameters/touchboost
	if [ -e $touchboost ]; then
		write $touchboost "0"
		sendToLog "$touchboost=0"
	fi;

	touch_boost=/sys/power/pnpmgr/touch_boost
	if [ -e $touch_boost ]; then
		write $touch_boost "N"
		sendToLog "$touch_boost=N"
	fi;

	#Disable CPU Boost
	boost_ms=/sys/module/cpu_boost/parameters/boost_ms
	if [ -e $boost_ms ]; then
		write $boost_ms "N"
		sendToLog "$boost_ms=N"
	fi;

	sched_boost_on_input=/sys/module/cpu_boost/parameters/sched_boost_on_input
	if [ -e $sched_boost_on_input ]; then
		write $sched_boost_on_input "N"
		sendToLog "$sched_boost_on_input=N"
	fi;

	sh $CPUSET_TUNER 3

	sendToLog "Performance CPU optimization applied";
	sendToLog "$divider";
}

governorTuner() {
	if [ "$1" = "1" ] || [ "$1" = "2" ] || [ "$1" = "3" ]; then
		sendToLog "Starting governor tuner background service"
		sh $BINARY_DIR/governor_tuner &

		sendToLog "Successfully started governor tuner background service, changes will be done in a while"
	else 
		sendToLog "Cannot start governor tuner, wrong or missing argument"
	fi
	
	sendToLog "$divider";
}

entropyAggressive() {
sendToLog "Activating aggressive entropy profile..."

$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=512
$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=1024
$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90

sendToLog "Aggressive entropy profile activated"
sendToLog "$divider";
}

entropyEnlarger() {
sendToLog "Activating enlarger entropy profile..."

$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=128
$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=896
$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90

sendToLog "Enlarger entropy profile activated"
sendToLog "$divider";
}

entropyLight() {
sendToLog "Activating light entropy profile..."

$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=64
$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=128
$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90

sendToLog "Light entropy profile activated"
sendToLog "$divider";
}

entropyModerate() {
sendToLog "Activating moderate entropy profile..."

$BUSYBOX sysctl -e -w kernel.random.read_wakeup_threshold=128
$BUSYBOX sysctl -e -w kernel.random.write_wakeup_threshold=256
$BUSYBOX sysctl -e -w kernel.random.urandom_min_reseed_secs=90

sendToLog "Moderate entropy profile activated"
sendToLog "$divider";
}

gpuOptimizerBalanced() {
sendToLog "Applying balanced GPU optimization...";

# GPU related tweaks
if [ -d "/sys/class/kgsl/kgsl-3d0" ]; then
	gpu="/sys/class/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/platform/*.gpu/devfreq/*.gpu" ]; then
	gpu="/sys/devices/platform/*.gpu/devfreq/*.gpu"
elif [ -d "/sys/devices/platform/gpusysfs" ]; then
	gpu="/sys/devices/platform/gpusysfs"
elif [ -d "/sys/devices/*.mali" ]; then
	gpu="/sys/devices/*.mali"
elif [ -d "/sys/devices/*.gpu" ]; then
	gpu="/sys/devices/*.gpu"
elif [ -d "/sys/devices/platform/mali.0" ]; then
	gpu="/sys/devices/platform/mali.0"
elif [ -d "/sys/devices/platform/mali-*.0" ]; then
	gpu="/sys/devices/platform/mali-*.0"
elif [ -d "/sys/module/mali/parameters" ]; then
	gpu="/sys/module/mali/parameters"
elif [ -d "/sys/class/misc/mali0" ]; then
	gpu="/sys/class/misc/mali0"
elif [ -d "/sys/kernel/gpu" ]; then
	gpu="/sys/kernel/gpu"
fi

if [ "$memTotal" -lt 3072 ]; then
	resetprop ro.hwui.texture_cache_size $((memTotal*10/100/2));
	resetprop ro.hwui.layer_cache_size $((memTotal*5/100/2));
	resetprop ro.hwui.path_cache_size $((memTotal*2/100/2));
	resetprop ro.hwui.r_buffer_cache_size $((memTotal/100/2));
	resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100/2));
	resetprop ro.hwui.texture_cache_flushrate 0.3
else 
	resetprop ro.hwui.texture_cache_size $((memTotal*10/100));
	resetprop ro.hwui.layer_cache_size $((memTotal*5/100));
	resetprop ro.hwui.path_cache_size $((memTotal*2/100));
	resetprop ro.hwui.r_buffer_cache_size $((memTotal/100));
	resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100));
	resetprop ro.hwui.texture_cache_flushrate 0.3
fi
sendToLog "Optimized GPU caches";

if [ -e /proc/gpufreq/gpufreq_limited_thermal_ignore ]; then
	write /proc/gpufreq/gpufreq_limited_thermal_ignore "1"		
	sendToLog "Disabled gpufreq thermal"
fi;

if [ -e /proc/mali/dvfs_enable ]; then
	write /proc/mali/dvfs_enable "1"		
	sendToLog "dvfs enabled"
fi;

if [ -e /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate ]; then
	write /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate "1"		
	sendToLog "Simple GPU algorithm enabled"
fi;

# Adreno idler
if [ -e /sys/module/adreno_idler/parameters/adreno_idler_active ]; then
	write /sys/module/adreno_idler/parameters/adreno_idler_active "Y"
	write /sys/module/adreno_idler/parameters/adreno_idler_idleworkload "6000"
	write /sys/module/adreno_idler/parameters/adreno_idler_downdifferential "15"
	write /sys/module/adreno_idler/parameters/adreno_idler_idlewait "15"
	sendToLog "Disabled and tweaked adreno idler"
fi;

if [ -e $gpu/devfreq/adrenoboost ]; then
	write $gpu/devfreq/adrenoboost "1"
	sendToLog "Adreno boost is set to 1"
fi;

if [ -e $gpu/throttling ]; then
	write $gpu/throttling "0"
	sendToLog "GPU throttling disabled"
fi;

if [ -e $gpu/max_pwrlevel ]; then
	write $gpu/max_pwrlevel "0"
	sendToLog "GPU max power level disabled"
fi;

if [ -e $gpu/force_no_nap ]; then
	write $gpu/force_no_nap "1"
	sendToLog "force_no_nap enabled"
fi;

if [ -e $gpu/bus_split ]; then
	write $gpu/bus_split "1"
	sendToLog "bus_split enabled"
fi;

if [ -e $gpu/force_bus_on ]; then
	write $gpu/force_bus_on "1"		
	sendToLog "force_bus_on enabled"
fi;

if [ -e $gpu/force_clk_on ]; then
	write $gpu/force_clk_on "1"		
	sendToLog "force_clk_on enabled"
fi;
	
if [ -e $gpu/force_rail_on ]; then
	write $gpu/force_rail_on "1"		
	sendToLog "force_rail_on enabled"
fi;

sendToLog "Balanced GPU optimization applied"
sendToLog "$divider";
}

gpuOptimizerPerformance() {
sendToLog "Applying performance GPU optimization...";

# GPU related tweaks
if [ -d "/sys/class/kgsl/kgsl-3d0" ]; then
	gpu="/sys/class/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/platform/*.gpu/devfreq/*.gpu" ]; then
	gpu="/sys/devices/platform/*.gpu/devfreq/*.gpu"
elif [ -d "/sys/devices/platform/gpusysfs" ]; then
	gpu="/sys/devices/platform/gpusysfs"
elif [ -d "/sys/devices/*.mali" ]; then
	gpu="/sys/devices/*.mali"
elif [ -d "/sys/devices/*.gpu" ]; then
	gpu="/sys/devices/*.gpu"
elif [ -d "/sys/devices/platform/mali.0" ]; then
	gpu="/sys/devices/platform/mali.0"
elif [ -d "/sys/devices/platform/mali-*.0" ]; then
	gpu="/sys/devices/platform/mali-*.0"
elif [ -d "/sys/module/mali/parameters" ]; then
	gpu="/sys/module/mali/parameters"
elif [ -d "/sys/class/misc/mali0" ]; then
	gpu="/sys/class/misc/mali0"
elif [ -d "/sys/kernel/gpu" ]; then
	gpu="/sys/kernel/gpu"
fi

if [ "$memTotal" -lt 3072 ]; then
	resetprop ro.hwui.texture_cache_size $((memTotal*10/100/2));
	resetprop ro.hwui.layer_cache_size $((memTotal*5/100/2));
	resetprop ro.hwui.path_cache_size $((memTotal*2/100/2));
	resetprop ro.hwui.r_buffer_cache_size $((memTotal/100/2));
	resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100/2));
	resetprop ro.hwui.texture_cache_flushrate 0.3
else 
	resetprop ro.hwui.texture_cache_size $((memTotal*10/100));
	resetprop ro.hwui.layer_cache_size $((memTotal*5/100));
	resetprop ro.hwui.path_cache_size $((memTotal*2/100));
	resetprop ro.hwui.r_buffer_cache_size $((memTotal/100));
	resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100));
	resetprop ro.hwui.texture_cache_flushrate 0.3
fi
sendToLog "Optimized GPU caches";

if [ -e /proc/gpufreq/gpufreq_limited_thermal_ignore ]; then
	write /proc/gpufreq/gpufreq_limited_thermal_ignore "1"		
	sendToLog "Disabled gpufreq thermal"
fi;

if [ -e /proc/mali/dvfs_enable ]; then
	write /proc/mali/dvfs_enable "1"		
	sendToLog "dvfs enabled"
fi;

if [ -e /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate ]; then
	write /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate "1"		
	sendToLog "Simple GPU algorithm enabled"
fi;

# Adreno idler
if [ -e /sys/module/adreno_idler/parameters/adreno_idler_active ]; then
	write /sys/module/adreno_idler/parameters/adreno_idler_active "N"
	write /sys/module/adreno_idler/parameters/adreno_idler_idleworkload "6000"
	write /sys/module/adreno_idler/parameters/adreno_idler_downdifferential "15"
	write /sys/module/adreno_idler/parameters/adreno_idler_idlewait "15"
	sendToLog "Disabled and tweaked adreno idler"
fi;

if [ -e $gpu/devfreq/adrenoboost ]; then
	write $gpu/devfreq/adrenoboost "2"
	sendToLog "Adreno boost is set to 2"
fi;

if [ -e $gpu/throttling ]; then
	write $gpu/throttling "0"
	sendToLog "GPU throttling disabled"
fi;

if [ -e $gpu/max_pwrlevel ]; then
	write $gpu/max_pwrlevel "0"
	sendToLog "GPU max power level disabled"
fi;

if [ -e $gpu/force_no_nap ]; then
	write $gpu/force_no_nap "1"
	sendToLog "force_no_nap enabled"
fi;

if [ -e $gpu/bus_split ]; then
	write $gpu/bus_split "0"
	sendToLog "bus_split disabled"
fi;

if [ -e $gpu/force_bus_on ]; then
	write $gpu/force_bus_on "1"		
	sendToLog "force_bus_on enabled"
fi;

if [ -e $gpu/force_clk_on ]; then
	write $gpu/force_clk_on "1"		
	sendToLog "force_clk_on enabled"
fi;
	
if [ -e $gpu/force_rail_on ]; then
	write $gpu/force_rail_on "1"		
	sendToLog "force_rail_on enabled"
fi;

sendToLog "Performance GPU optimization applied"
sendToLog "$divider";
}

gpuOptimizerPowerSaving() {
sendToLog "Applying power saving GPU optimization...";

# GPU related tweaks
if [ -d "/sys/class/kgsl/kgsl-3d0" ]; then
	gpu="/sys/class/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/platform/kgsl-3d0.0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/soc/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0" ]; then
	gpu="/sys/devices/soc.0/*.qcom,kgsl-3d0/kgsl/kgsl-3d0"
elif [ -d "/sys/devices/platform/*.gpu/devfreq/*.gpu" ]; then
	gpu="/sys/devices/platform/*.gpu/devfreq/*.gpu"
elif [ -d "/sys/devices/platform/gpusysfs" ]; then
	gpu="/sys/devices/platform/gpusysfs"
elif [ -d "/sys/devices/*.mali" ]; then
	gpu="/sys/devices/*.mali"
elif [ -d "/sys/devices/*.gpu" ]; then
	gpu="/sys/devices/*.gpu"
elif [ -d "/sys/devices/platform/mali.0" ]; then
	gpu="/sys/devices/platform/mali.0"
elif [ -d "/sys/devices/platform/mali-*.0" ]; then
	gpu="/sys/devices/platform/mali-*.0"
elif [ -d "/sys/module/mali/parameters" ]; then
	gpu="/sys/module/mali/parameters"
elif [ -d "/sys/class/misc/mali0" ]; then
	gpu="/sys/class/misc/mali0"
elif [ -d "/sys/kernel/gpu" ]; then
	gpu="/sys/kernel/gpu"
fi

if [ "$memTotal" -lt 3072 ]; then
	resetprop ro.hwui.texture_cache_size $((memTotal*10/100/2));
	resetprop ro.hwui.layer_cache_size $((memTotal*5/100/2));
	resetprop ro.hwui.path_cache_size $((memTotal*2/100/2));
	resetprop ro.hwui.r_buffer_cache_size $((memTotal/100/2));
	resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100/2));
	resetprop ro.hwui.texture_cache_flushrate 0.3
else 
	resetprop ro.hwui.texture_cache_size $((memTotal*10/100));
	resetprop ro.hwui.layer_cache_size $((memTotal*5/100));
	resetprop ro.hwui.path_cache_size $((memTotal*2/100));
	resetprop ro.hwui.r_buffer_cache_size $((memTotal/100));
	resetprop ro.hwui.drop_shadow_cache_size $((memTotal/100));
	resetprop ro.hwui.texture_cache_flushrate 0.3
fi
sendToLog "Optimized GPU caches";


if [ -e /proc/gpufreq/gpufreq_limited_thermal_ignore ]; then
	write /proc/gpufreq/gpufreq_limited_thermal_ignore "1"
	sendToLog "Disabled gpufreq thermal"
fi;

if [ -e /proc/mali/dvfs_enable ]; then
	write /proc/mali/dvfs_enable "1"
	sendToLog "dvfs enabled"
fi;

if [ -e /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate ]; then
	write /sys/module/simple_gpu_algorithm/parameters/simple_gpu_activate "1"
	sendToLog "Simple GPU algorithm enabled"
fi;

# Adreno idler
if [ -e /sys/module/adreno_idler/parameters/adreno_idler_active ]; then
	write /sys/module/adreno_idler/parameters/adreno_idler_active "Y"
	write /sys/module/adreno_idler/parameters/adreno_idler_idleworkload "10000"
	write /sys/module/adreno_idler/parameters/adreno_idler_downdifferential "35"
	write /sys/module/adreno_idler/parameters/adreno_idler_idlewait "25"
	sendToLog "Enabled and tweaked adreno idler"
fi;

if [ -e $gpu/devfreq/adrenoboost ]; then
	write $gpu/devfreq/adrenoboost "0"
	sendToLog "Adreno boost is set to 0"
fi;

if [ -e $gpu/throttling ]; then
	write $gpu/throttling "0"
	sendToLog "GPU throttling disabled"
fi;

if [ -e $gpu/max_pwrlevel ]; then
	write $gpu/max_pwrlevel "0"
	sendToLog "GPU max power level disabled"
fi;

if [ -e $gpu/force_no_nap ]; then
	write $gpu/force_no_nap "0"
	sendToLog "force_no_nap disabled"
fi;

if [ -e $gpu/bus_split ]; then
	write $gpu/bus_split "1"
	sendToLog "bus_split enabled"
fi;

if [ -e $gpu/force_bus_on ]; then
	write $gpu/force_bus_on "0"
	sendToLog "force_bus_on disabled"
fi;

if [ -e $gpu/force_clk_on ]; then
	write $gpu/force_clk_on "0"
	sendToLog "force_clk_on disabled"
fi;

if [ -e $gpu/force_rail_on ]; then
	write $gpu/force_rail_on "0"
	sendToLog "force_rail_on disabled"
fi;

sendToLog "Power saving GPU optimization applied"
sendToLog "$divider";
}

optimizeBuffers() {
sendToLog "Changing GPU buffer count"

setprop debug.egl.buffcount 4

sendToLog "GPU buffer count set to 4"
sendToLog "$divider";
}

renderOpenglesUsingGpu() {
sendToLog "Setting GPU to render OpenGLES..."

setprop debug.egl.hw 1

sendToLog "GPU successfully set up to render OpenGLES"
sendToLog "$divider";
}

useOpenglSkia() {
sendToLog "Changing app rendering to skiagl..."

setprop debug.hwui.renderer skiagl

sendToLog "Rendering chaned to skiagl"
sendToLog "$divider";
}

forceGpuRendering() {

if [ $1 -eq 0 ]; then
	sendToLog "Disabling force GPU rendering..."
	setprop persist.sys.ui.hw 0
	sendToLog "Force GPU rendering successfully disabled"
elif [ $1 -eq 1 ]; then
	sendToLog "Enabling force GPU rendering..."
	setprop persist.sys.ui.hw 1
	sendToLog "Force GPU rendering successfully enabled"
fi
 
sendToLog "$divider";
}

force4xMsaa() {

if [ $1 -eq 0 ]; then
	sendToLog "Disabling force 4x MSAA..."
	setprop debug.egl.force_msaa 0
	sendToLog "Force 4x MSAA successfully disabled"
elif [ $1 -eq 1 ]; then
	sendToLog "Enabling force 4x MSAA..."
	setprop debug.egl.force_msaa 1
	sendToLog "Force 4x MSAA successfully enabled"
fi
 
sendToLog "$divider";
}

enableIoStats() {
sendToLog "Enabling I/O Stats..."

blocks="/sys/block/*"

for i in $blocks;
	do
		write "$i/queue/iostats" "1"
		sendToLog "iostats=1 in $i"
done

sendToLog "I/O Stats enabled"
sendToLog "$divider";
}

disableIoStats() {
sendToLog "Disabling I/O Stats..."

blocks="/sys/block/*"

for i in $blocks;
	do
		write "$i/queue/iostats" "0"
		sendToLog "iostats=0 in $i"
done

sendToLog "I/O Stats disabled"
sendToLog "$divider";
}

sdTweak() {

# Storage blocks eMMC
DEV_MMCBLK0="/dev/block/mmcblk0";
MMCBLK0="/sys/block/mmcblk0";
MMCBLK0_READ_AHEAD_KB="$MMCBLK0/queue/read_ahead_kb";
DEV_MMCBLK1="/dev/block/mmcblk1";
MMCBLK1="/sys/block/mmcblk1";
MMCBLK1_READ_AHEAD_KB="$MMCBLK1/queue/read_ahead_kb";

# Storage blocks UFS
SDA="/sys/block/sda";

sendToLog "Activating SD speed tweak";

# On some devices:
# SD* and MMCBLK0 is sdcard
#

if [ -e $SDA ] && [ -e $MMCBLK0 ]; then

	sendToLog "SD card mounted on $DEV_MMCBLK0";
	external_totalSize=$(blockdev --getsize64 $DEV_MMCBLK0);

	if [ "$external_totalSize" -lt 8589934592 ]; then
		extReadAhead="256";
	elif [ "$external_totalSize" -ge 8589934592 ] && [ "$external_totalSize" -lt 17179869184 ]; then
		extReadAhead="512";
	elif [ "$external_totalSize" -ge 17179869184 ] && [ "$external_totalSize" -lt 34359738368 ]; then
		extReadAhead="1024";
	elif [ "$external_totalSize" -ge 34359738368 ]; then
		extReadAhead="2048";
	else
		extReadAhead="256";
	fi

	sendToLog "Your SD Card size is: $((external_totalSize/1024/1024/1024))kb";
	sendToLog "Read Ahead based on SD Card size: $((extReadAhead))kb";
	write $MMCBLK0_READ_AHEAD_KB $extReadAhead;
	sendToLog "SD speed tweak is activated";

elif [ -e $SDA ] && [ -e $MMCBLK1 ]; then

	sendToLog "SD card mounted on $DEV_MMCBLK1";
	external_totalSize=$(blockdev --getsize64 $DEV_MMCBLK1);

	if [ "$external_totalSize" -lt 8589934592 ]; then
		extReadAhead="256";
	elif [ "$external_totalSize" -ge 8589934592 ] && [ "$external_totalSize" -lt 17179869184 ]; then
		extReadAhead="512";
	elif [ "$external_totalSize" -ge 17179869184 ] && [ "$external_totalSize" -lt 34359738368 ]; then
		extReadAhead="1024";
	elif [ "$external_totalSize" -ge 34359738368 ]; then
		extReadAhead="2048";
	else
		extReadAhead="256";
	fi

	sendToLog "Your SD Card size is: $((external_totalSize/1024/1024/1024))kb";
	sendToLog "Read Ahead based on SD Card size: $((extReadAhead))kb";
	write $MMCBLK1_READ_AHEAD_KB $extReadAhead;
	sendToLog "SD speed tweak is activated";
	
elif [ -e $MMCBLK1 ]; then

	sendToLog "SD card mounted on $DEV_MMCBLK1";
	external_totalSize=$(blockdev --getsize64 $DEV_MMCBLK1);

	if [ "$external_totalSize" -lt 8589934592 ]; then
		extReadAhead="256";
	elif [ "$external_totalSize" -ge 8589934592 ] && [ "$external_totalSize" -lt 17179869184 ]; then
		extReadAhead="512";
	elif [ "$external_totalSize" -ge 17179869184 ] && [ "$external_totalSize" -lt 34359738368 ]; then
		extReadAhead="1024";
	elif [ "$external_totalSize" -ge 34359738368 ]; then
		extReadAhead="2048";
	else
		extReadAhead="256";
	fi

	sendToLog "Your SD Card size is: $((external_totalSize/1024/1024/1024))kb";
	sendToLog "Read Ahead based on SD Card size: $((extReadAhead))kb";
	write $MMCBLK1_READ_AHEAD_KB $extReadAhead;
	sendToLog "SD speed tweak is activated";

else
	sendToLog "SD card not available or not supported...";

fi
sendToLog "$divider";
}
 
ioBlocksOptimizationBalanced() {
sendToLog "Activating balanced I/O blocks optimization..."

blocks="/sys/block/*"

for i in $blocks;
	do
	
	#This file allows to turn off the disk entropy contribution. Default
	#value of this file is '1'(on).
	if [ -e "$i/queue/add_random" ]; then
		write "$i/queue/add_random" "0"
		sendToLog "add_random=0 in $i"
	fi
	
	#This enables the user to disable the lookup logic involved with IO
	#merging requests in the block layer. By default (0) all merges are
	#enabled. When set to 1 only simple one-hit merges will be tried. When
	#set to 2 no merge algorithms will be tried (including one-hit or more
	#complex tree/hash lookups).
	if [ -e "$i/queue/nomerges" ]; then
		write "$i/queue/nomerges" "2"
		sendToLog "nomerges=2 in $i"
	fi
		
	#If this option is '1', the block layer will migrate request completions to the
	#cpu "group" that originally submitted the request. For some workloads this
	#provides a significant reduction in CPU cycles due to caching effects.
	#For storage configurations that need to maximize distribution of completion
	#processing setting this option to '2' forces the completion to run on the
	#requesting cpu (bypassing the "group" aggregation logic).
	if [ -e "$i/queue/rq_affinity" ]; then
		write "$i/queue/rq_affinity" "1"
		sendToLog "rq_affinity=1 in $i"
	fi
	
	#This controls how many requests may be allocated in the block layer for
	#read or write requests. Note that the total allocated number may be twice
	#this amount, since it applies only to reads or writes (not the accumulated
	#sum).
	#To avoid priority inversion through request starvation, a request
	#queue maintains a separate request pool per each cgroup when
	#CONFIG_BLK_CGROUP is enabled, and this parameter applies to each such
	#per-block-cgroup request pool.  IOW, if there are N block cgroups,
	#each request queue may have up to N request pools, each independently
	#regulated by nr_requests.
	if [ -e "$i/queue/nr_requests" ]; then
		write "$i/queue/nr_requests" "128"
		sendToLog "nr_requests=128 in $i"
	fi
	
	#Maximum number of kilobytes to read-ahead for filesystems on this block
	#device.
	if [ -e "$i/queue/read_ahead_kb" ]; then
		write "$i/queue/read_ahead_kb" "128"
		sendToLog "read_ahead_kb=128 in $i"
	fi
	
	# Tell scheduler that it's facing with non rotational drive to disable
	# unnecessary seek-reducing logic in the scheduler. We are not using rotational HDDs
	#if [ -e "$i/queue/rotational" ]; then
	#	write "$i/queue/rotational" "0"
	#	sendToLog "rotational=0 in $i"
	#fi
	
done

# MMC CRC disabled
removable=/sys/module/mmc_core/parameters/removable
if [ -e $removable ]; then
	write $removable "N"
	sendToLog "CRC Checks disabled $removable"
fi;

crc=/sys/module/mmc_core/parameters/crc
if [ -e $crc ]; then
	write $crc "N"
	sendToLog "CRC Checks disabled $crc"
fi;

use_spi_crc=/sys/module/mmc_core/parameters/use_spi_crc
if [ -e $use_spi_crc ]; then
	write $use_spi_crc "N"
	sendToLog "CRC Checks disabled $use_spi_crc"
fi;

sendToLog "Balanced I/O blocks optimization activated"
sendToLog "$divider";
}

ioBlocksOptimizationPerformance() {
sendToLog "Activating performance I/O blocks optimization..."

blocks="/sys/block/*"

for i in $blocks;
	do
	
	#This file allows to turn off the disk entropy contribution. Default
	#value of this file is '1'(on).
	if [ -e "$i/queue/add_random" ]; then
		write "$i/queue/add_random" "0"
		sendToLog "add_random=0 in $i"
	fi
	
	#This enables the user to disable the lookup logic involved with IO
	#merging requests in the block layer. By default (0) all merges are
	#enabled. When set to 1 only simple one-hit merges will be tried. When
	#set to 2 no merge algorithms will be tried (including one-hit or more
	#complex tree/hash lookups).
	if [ -e "$i/queue/nomerges" ]; then
		write "$i/queue/nomerges" "2"
		sendToLog "nomerges=2 in $i"
	fi
		
	#If this option is '1', the block layer will migrate request completions to the
	#cpu "group" that originally submitted the request. For some workloads this
	#provides a significant reduction in CPU cycles due to caching effects.
	#For storage configurations that need to maximize distribution of completion
	#processing setting this option to '2' forces the completion to run on the
	#requesting cpu (bypassing the "group" aggregation logic).
	if [ -e "$i/queue/rq_affinity" ]; then
		write "$i/queue/rq_affinity" "1"
		sendToLog "rq_affinity=1 in $i"
	fi
	
	#This controls how many requests may be allocated in the block layer for
	#read or write requests. Note that the total allocated number may be twice
	#this amount, since it applies only to reads or writes (not the accumulated
	#sum).
	#To avoid priority inversion through request starvation, a request
	#queue maintains a separate request pool per each cgroup when
	#CONFIG_BLK_CGROUP is enabled, and this parameter applies to each such
	#per-block-cgroup request pool.  IOW, if there are N block cgroups,
	#each request queue may have up to N request pools, each independently
	#regulated by nr_requests.
	if [ -e "$i/queue/nr_requests" ]; then
		write "$i/queue/nr_requests" "256"
		sendToLog "nr_requests=256 in $i"
	fi
	
	#Maximum number of kilobytes to read-ahead for filesystems on this block
	#device.
	if [ -e "$i/queue/read_ahead_kb" ]; then
		write "$i/queue/read_ahead_kb" "256"
		sendToLog "read_ahead_kb=256 in $i"
	fi
	
	# Tell scheduler that it's facing with non rotational drive to disable
	# unnecessary seek-reducing logic in the scheduler. We are not using rotational HDDs
	#if [ -e "$i/queue/rotational" ]; then
	#	write "$i/queue/rotational" "0"
	#	sendToLog "rotational=0 in $i"
	#fi
	
done

# MMC CRC disabled
removable=/sys/module/mmc_core/parameters/removable
if [ -e $removable ]; then
	write $removable "N"
	sendToLog "CRC Checks disabled $removable"
fi;

crc=/sys/module/mmc_core/parameters/crc
if [ -e $crc ]; then
	write $crc "N"
	sendToLog "CRC Checks disabled $crc"
fi;

use_spi_crc=/sys/module/mmc_core/parameters/use_spi_crc
if [ -e $use_spi_crc ]; then
	write $use_spi_crc "N"
	sendToLog "CRC Checks disabled $use_spi_crc"
fi;

sendToLog "Performance I/O blocks optimization activated"
sendToLog "$divider";
}

ioBlocksOptimizationPowerSaving() {
sendToLog "Activating power saving I/O blocks optimization..."

blocks="/sys/block/*"

for i in $blocks;
	do
	
	#This file allows to turn off the disk entropy contribution. Default
	#value of this file is '1'(on).
	if [ -e "$i/queue/add_random" ]; then
		write "$i/queue/add_random" "0"
		sendToLog "add_random=0 in $i"
	fi
	
	#This enables the user to disable the lookup logic involved with IO
	#merging requests in the block layer. By default (0) all merges are
	#enabled. When set to 1 only simple one-hit merges will be tried. When
	#set to 2 no merge algorithms will be tried (including one-hit or more
	#complex tree/hash lookups).
	if [ -e "$i/queue/nomerges" ]; then
		write "$i/queue/nomerges" "2"
		sendToLog "nomerges=2 in $i"
	fi
	
	#If this option is '1', the block layer will migrate request completions to the
	#cpu "group" that originally submitted the request. For some workloads this
	#provides a significant reduction in CPU cycles due to caching effects.
	#For storage configurations that need to maximize distribution of completion
	#processing setting this option to '2' forces the completion to run on the
	#requesting cpu (bypassing the "group" aggregation logic).
	if [ -e "$i/queue/rq_affinity" ]; then
		write "$i/queue/rq_affinity" "1"
		sendToLog "rq_affinity=1 in $i"
	fi
	
	#This controls how many requests may be allocated in the block layer for
	#read or write requests. Note that the total allocated number may be twice
	#this amount, since it applies only to reads or writes (not the accumulated
	#sum).
	#To avoid priority inversion through request starvation, a request
	#queue maintains a separate request pool per each cgroup when
	#CONFIG_BLK_CGROUP is enabled, and this parameter applies to each such
	#per-block-cgroup request pool.  IOW, if there are N block cgroups,
	#each request queue may have up to N request pools, each independently
	#regulated by nr_requests.
	if [ -e "$i/queue/nr_requests" ]; then
		write "$i/queue/nr_requests" "64"
		sendToLog "nr_requests=64 in $i"
	fi
	
	#Maximum number of kilobytes to read-ahead for filesystems on this block
	#device.
	if [ -e "$i/queue/read_ahead_kb" ]; then
		write "$i/queue/read_ahead_kb" "128"
		sendToLog "read_ahead_kb=128 in $i"
	fi

	# Tell scheduler that it's facing with non rotational drive to disable
	# unnecessary seek-reducing logic in the scheduler. We are not using rotational HDDs
	#if [ -e "$i/queue/rotational" ]; then
	#	write "$i/queue/rotational" "0"
	#	sendToLog "rotational=0 in $i"
	#fi
	
done

# MMC CRC disabled
removable=/sys/module/mmc_core/parameters/removable
if [ -e $removable ]; then
	write $removable "N"
	sendToLog "CRC Checks disabled $removable"
fi;

crc=/sys/module/mmc_core/parameters/crc
if [ -e $crc ]; then
	write $crc "N"
	sendToLog "CRC Checks disabled $crc"
fi;

use_spi_crc=/sys/module/mmc_core/parameters/use_spi_crc
if [ -e $use_spi_crc ]; then
	write $use_spi_crc "N"
	sendToLog "CRC Checks disabled $use_spi_crc"
fi;

sendToLog "Power saving I/O blocks optimization activated"
sendToLog "$divider";
}

ioExtendedQueue() {
sendToLog "Activating I/O extend queue..."

blocks="/sys/block/*"

for i in $blocks;
	do
	if [ -e "$i" ]; then
		write "$i/queue/nr_requests" "512"
		sendToLog "nr_requests=512 in $i"
	fi
done

sendToLog "I/O extend queue is activated"
sendToLog "$divider";
}

schedulerTuner() {

sendToLog "Activating scheduler tuner..."
	
blocks="/sys/block/*"

for i in $blocks;
	do
	scheduler=$(getScheduler "$i")
		
	# deadline
	FIFO_BATCH="$i/queue/iosched/fifo_batch";
	FRONT_MERGES="$i/queue/iosched/front_merges";
	READ_EXPIRE="$i/queue/iosched/read_expire";
	WRITE_EXPIRE="$i/queue/iosched/write_expire";
	WRITES_STARVED="$i/queue/iosched/writes_starved";

	# anxiety
	MAX_WRITES_STARVED="$i/queue/iosched/max_writes_starved";

	# cfq
	BACK_SEEK_PENALTY="$i/queue/iosched/back_seek_penalty";
	FIFO_EXPIRE_ASYNC="$i/queue/iosched/fifo_expire_async";
	FIFO_EXPIRE_SYNC="$i/queue/iosched/fifo_expire_sync";
	GROUP_IDLE="$i/queue/iosched/group_idle";
	LOW_LATENCY="$i/queue/iosched/low_latency";
	QUANTUM="$i/queue/iosched/quantum";
	SLICE_ASYNC="$i/queue/iosched/slice_async";
	SLICE_ASYNC_RQ="$i/queue/iosched/slice_async_rq";
	SLICE_IDLE="$i/queue/iosched/slice_idle";
	SLICE_SYNC="$i/queue/iosched/slice_sync";
	TARGET_LATENCY="$i/queue/iosched/target_latency";

	# bfq
	MAX_BUDGET="$i/queue/iosched/max_budget";
	MAX_BUDGET_ASYNC_RQ="$i/queue/iosched/max_budget_async_rq";
	TIMEOUT_ASYNC="$i/queue/iosched/timeout_async";
	TIMEOUT_SYNC="$i/queue/iosched/timeout_sync";
	WR_COEOFF="$i/queue/iosched/wr_coeff";
	WR_MAX_SOFTRT_RATE="$i/queue/iosched/wr_max_softrt_rate";
	WR_MAX_TIME="$i/queue/iosched/wr_max_time";
	WR_MIN_IDLE_TIME="$i/queue/iosched/wr_min_idle_time";
	WR_MIN_INTER_ARR_ASYNC="$i/queue/iosched/wr_min_inter_arr_async";
	WR_RT_MAX_TIME="$i/queue/iosched/wr_rt_max_time";

	# row
	HP_READ_QUANTUM="$i/queue/iosched/hp_read_quantum";
	HP_SWRITE_QUANTUM="$i/queue/iosched/hp_swrite_quantum";
	LOW_STARV_LIMIT="$i/queue/iosched/low_starv_limit";
	LP_READ_QUANTUM="$i/queue/iosched/lp_read_quantum";
	LP_SWRITE_QUANTUM="$i/queue/iosched/lp_swrite_quantum";
	RD_IDLE_DATA="$i/queue/iosched/rd_idle_data";
	RD_IDLE_DATA_FREQ="$i/queue/iosched/rd_idle_data_freq";
	READ_IDLE="$i/queue/iosched/read_idle";
	READ_IDLE_FREQ="$i/queue/iosched/read_idle_freq";
	REG_STARV_LIMIT="$i/queue/iosched/reg_starv_limit";
	RP_READ_QUANTUM="$i/queue/iosched/rp_read_quantum";
	RP_SWRITE_QUANTUM="$i/queue/iosched/rp_swrite_quantum";
	RP_WRITE_QUANTUM="$i/queue/iosched/rp_write_quantum";

	# fiops
	ASYNC_SCALE="$i/queue/iosched/async_scale";
	READ_SCALE="$i/queue/iosched/read_scale";
	SYNC_SCALE="$i/queue/iosched/sync_scale";
	WRITE_SCALE="$i/queue/iosched/write_scale";

	# sio/sioplus
	ASYNC_READ_EXPIRE="$i/queue/iosched/async_read_expire";
	ASYNC_WRITE_EXPIRE="$i/queue/iosched/async_write_expire";
	SYNC_READ_EXPIRE="$i/queue/iosched/sync_read_expire";
	SYNC_WRITE_EXPIRE="$i/queue/iosched/sync_write_expire";

	# zen
	ASYNC_EXPIRE="$i/queue/iosched/async_expire";
	SYNC_EXPIRE="$i/queue/iosched/sync_expire";
	
	# Write log when found a scheduler in block
	# This log contains current scheduler in $i block
	if [ "$scheduler" != "none" ]; then
		sendToLog "Found $scheduler in $i"
	fi
	
	# deadline
	if [ "$scheduler" = "deadline" ]; then
		if [ -e "$FIFO_BATCH" ]; then
			write "$FIFO_BATCH" "8"
			sendToLog "fifo_batch=8 in $i"
		fi
		
		if [ -e "$FRONT_MERGES" ]; then
			write "$FRONT_MERGES" "1"
			sendToLog "front_merges=1 in $i"
		fi
		
		if [ -e "$READ_EXPIRE" ]; then
			write "$READ_EXPIRE" "250"
			sendToLog "read_expire=250 in $i"
		fi
		
		if [ -e "$WRITE_EXPIRE" ]; then
			write "$WRITE_EXPIRE" "2500"
			sendToLog "write_expire=2500 in $i"
		fi

		if [ -e "$WRITES_STARVED" ]; then
			write "$WRITES_STARVED" "1"
			sendToLog "writes_starved=1 in $i"
		fi

	# anxiety
	elif [ "$scheduler" = "anxiety" ]; then
		if [ -e "$MAX_WRITES_STARVED" ]; then
			write "$MAX_WRITES_STARVED" "4"
			sendToLog "max_writes_starved=4 in $i"
		fi

	# cfq
	elif [ "$scheduler" = "cfq" ]; then
		if [ -e "$BACK_SEEK_PENALTY" ]; then
			write "$BACK_SEEK_PENALTY" "1"
			sendToLog "back_seek_penalty=1 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_ASYNC" ]; then
			write "$FIFO_EXPIRE_ASYNC" "330"
			sendToLog "fifo_expire_async=330 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_SYNC" ]; then
			write "$FIFO_EXPIRE_SYNC" "80"
			sendToLog "fifo_expire_sync=80 in $i"
		fi
		
		if [ -e "$GROUP_IDLE" ]; then
			write "$GROUP_IDLE" "1"
			sendToLog "group_idle=1 in $i"
		fi
		
		if [ -e "$LOW_LATENCY" ]; then
			write "$LOW_LATENCY" "0"
			sendToLog "low_latency=0 in $i"
		fi
		
		if [ -e "$QUANTUM" ]; then
			write "$QUANTUM" "8"
			sendToLog "quantum=8 in $i"
		fi
		
		if [ -e "$SLICE_ASYNC" ]; then
			write "$SLICE_ASYNC" "50"
			sendToLog "slice_async=50 in $i"
		fi
		
		if [ -e "$SLICE_ASYNC_RQ" ]; then
			write "$SLICE_ASYNC_RQ" "2"
			sendToLog "slice_async_rq=2 in $i"
		fi
		
		if [ -e "$SLICE_IDLE" ]; then
			write "$SLICE_IDLE" "0"
			sendToLog "slice_idle=0 in $i"
		fi
		
		if [ -e "$SLICE_SYNC" ]; then
			write "$SLICE_SYNC" "60"
			sendToLog "slice_sync=60 in $i"
		fi
		
		if [ -e "$TARGET_LATENCY" ]; then
			write "$TARGET_LATENCY", true "30"
			sendToLog "target_latency=300 in $i"
		fi

	# bfq
	elif [ "$scheduler" = "bfq" ]; then
		if [ -e "$BACK_SEEK_PENALTY" ]; then
			write "$BACK_SEEK_PENALTY" "1"
			sendToLog "back_seek_penalty=1 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_ASYNC" ]; then
			write "$FIFO_EXPIRE_ASYNC" "250"
			sendToLog "fifo_expire_async=250 in $i"
		fi
		
		if [ -e "$FIFO_EXPIRE_SYNC" ]; then
			write "$FIFO_EXPIRE_SYNC" "120"
			sendToLog "fifo_expire_sync=120 in $i"
		fi
		
		if [ -e "$LOW_LATENCY" ]; then
			write "$LOW_LATENCY" "0"
			sendToLog "low_latency=0 in $i"
		fi
		
		if [ -e "$MAX_BUDGET" ]; then
			write "$MAX_BUDGET" "0"
			sendToLog "max_budget=0 in $i"
		fi
		
		if [ -e "$MAX_BUDGET_ASYNC_RQ" ]; then
			write "$MAX_BUDGET_ASYNC_RQ" "4"
			sendToLog "max_budget_async_rq=4 in $i"
		fi
		
		if [ -e "$SLICE_IDLE" ]; then
			write "$SLICE_IDLE" "0"
			sendToLog "slice_idle=0 in $i"
		fi
		
		if [ -e "$TIMEOUT_ASYNC" ]; then
			write "$TIMEOUT_ASYNC" "40"
			sendToLog "timeout_async=40 in $i"
		fi
		
		if [ -e "$TIMEOUT_SYNC" ]; then
			write "$TIMEOUT_SYNC" "120"
			sendToLog "timeout_sync=120 in $i"
		fi
		
		if [ -e "$WR_COEOFF" ]; then
			write "$WR_COEOFF" "20"
			sendToLog "wr_coeff=20 in $i"
		fi
		
		if [ -e "$WR_MAX_SOFTRT_RATE" ]; then
			write "$WR_MAX_SOFTRT_RATE" "7000"
			sendToLog "wr_max_softrt_rate=7000 in $i"
		fi
		
		if [ -e "$WR_MAX_TIME" ]; then
			write "$WR_MAX_TIME" "2250"
			sendToLog "wr_max_time=2250 in $i"
		fi
		
		if [ -e "$WR_MIN_IDLE_TIME" ]; then
			write "$WR_MIN_IDLE_TIME" "2000"
			sendToLog "wr_min_idle_time=2000 in $i"
		fi
		
		if [ -e "$WR_MIN_INTER_ARR_ASYNC" ]; then
			write "$WR_MIN_INTER_ARR_ASYNC" "500"
			sendToLog "wr_min_inter_arr_async=500 in $i"
		fi
		
		if [ -e "$WR_RT_MAX_TIME" ]; then
			write "$WR_RT_MAX_TIME" "300"
			sendToLog "wr_rt_max_time=300 in $i"
		fi

	# row
	elif [ "$scheduler" = "row" ]; then
		if [ -e "$HP_READ_QUANTUM" ]; then
			write "$HP_READ_QUANTUM" "90"
			sendToLog "hp_read_quantum=90 in $i"
		fi
		
		if [ -e "$HP_SWRITE_QUANTUM" ]; then
			write "$HP_SWRITE_QUANTUM" "5"
			sendToLog "hp_swrite_quantum=5 in $i"
		fi
		
		if [ -e "$LOW_STARV_LIMIT" ]; then
			write "$LOW_STARV_LIMIT" "10000"
			sendToLog "low_starv_limit=10000 in $i"
		fi
		
		if [ -e "$LP_READ_QUANTUM" ]; then
			write "$LP_READ_QUANTUM" "3"
			sendToLog "lp_read_quantum=3 in $i"
		fi
		
		if [ -e "$LP_SWRITE_QUANTUM" ]; then
			write "$LP_SWRITE_QUANTUM" "10"
			sendToLog "lp_swrite_quantum=10 in $i"
		fi
		
		if [ -e "$RD_IDLE_DATA" ]; then
			write "$RD_IDLE_DATA" "10"
			sendToLog "rd_idle_data=10 in $i"
		fi
		
		if [ -e "$RD_IDLE_DATA_FREQ" ]; then
			write "$RD_IDLE_DATA_FREQ" "25"
			sendToLog "rd_idle_data_freq=25 in $i"
		fi
		
		if [ -e "$READ_IDLE" ]; then
			write "$READ_IDLE" "10"
			sendToLog "read_idle=10 in $i"
		fi
		
		if [ -e "$READ_IDLE_FREQ" ]; then
			write "$READ_IDLE_FREQ" "25"
			sendToLog "read_idle_freq=25 in $i"
		fi
		
		if [ -e "$REG_STARV_LIMIT" ]; then
			write "$REG_STARV_LIMIT" "5000"
			sendToLog "reg_starv_limit=5000 in $i"
		fi
		
		if [ -e "$RP_READ_QUANTUM" ]; then
			write "$RP_READ_QUANTUM" "75"
			sendToLog "rp_read_quantum=75 in $i"
		fi
		
		if [ -e "$RP_SWRITE_QUANTUM" ]; then
			write "$RP_SWRITE_QUANTUM" "4"
			sendToLog "rp_swrite_quantum=4 in $i"
		fi
		
		if [ -e "$RP_WRITE_QUANTUM" ]; then
			write "$RP_WRITE_QUANTUM" "4"
			sendToLog "rp_write_quantum=4 in $i"
		fi
	
	# fiops
	elif [ "$scheduler" = "fiops" ]; then
		if [ -e "$ASYNC_SCALE" ]; then
			write "$ASYNC_SCALE" "5"
			sendToLog "async_scale=5 in $i"
		fi
		
		if [ -e "$READ_SCALE" ]; then
			write "$READ_SCALE" "3"
			sendToLog "read_scale=3 in $i"
		fi
		
		if [ -e "$SYNC_SCALE" ]; then
			write "$SYNC_SCALE" "2"
			sendToLog "sync_scale=2 in $i"
		fi
		
		if [ -e "$WRITE_SCALE" ]; then
			write "$WRITE_SCALE" "4"
			sendToLog "write_scale=4 in $i"
		fi
	
	#  sio/sioplus
	elif [ "$scheduler" = "sio" ] || [ "$scheduler" = "sioplus" ]; then
		if [ -e "$ASYNC_READ_EXPIRE" ]; then
			write "$ASYNC_READ_EXPIRE" "500"
			sendToLog "async_read_expire=500 in $i"
		fi
		
		if [ -e "$ASYNC_WRITE_EXPIRE" ]; then
			write "$ASYNC_WRITE_EXPIRE" "2000"
			sendToLog "async_write_expire=2000 in $i"
		fi
		
		if [ -e "$FIFO_BATCH" ]; then
			write "$FIFO_BATCH" "3"
			sendToLog "fifo_batch=3 in $i"
		fi
		
		if [ -e "$SYNC_READ_EXPIRE" ]; then
			write "$SYNC_READ_EXPIRE" "250"
			sendToLog "sync_read_expire=250 in $i"
		fi
		
		if [ -e "$SYNC_WRITE_EXPIRE" ]; then
			write "$SYNC_WRITE_EXPIRE" "1250"
			sendToLog "sync_write_expire=1250 in $i"
		fi
		
		if [ -e "$WRITES_STARVED" ]; then
			write "$WRITES_STARVED" "1"
			sendToLog "writes_starved=1 in $i"
		fi

	# zen
	elif [ "$scheduler" = "zen" ]; then
		if [ -e "$ASYNC_EXPIRE" ]; then
			write "$ASYNC_EXPIRE" "2500"
			sendToLog "async_expire=2500 in $i"
		fi
		
		if [ -e "$FIFO_BATCH" ]; then
			write "$FIFO_BATCH" "8"
			sendToLog "fifo_batch=8 in $i"
		fi
		
		if [ -e "$SYNC_EXPIRE" ]; then
			write "$SYNC_EXPIRE" "300"
			sendToLog "sync_expire=300 in $i"
		fi
		
	else
		if [ "$scheduler" != "none" ]; then
			sendToLog "Scheduler $scheduler in $i is not supported"
		fi
	fi
	
	done
	sendToLog "Scheduler tuner is activated"
	sendToLog "$divider";
}

dnsOptimizationCloudFlare() {
sendToLog "Activating DNS optimization..."

iptables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to 1.0.0.1:53
iptables -t nat -I OUTPUT -p udp --dport 53 -j DNAT --to 1.0.0.1:53
iptables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to 1.1.1.1:53
iptables -t nat -I OUTPUT -p tcp --dport 53 -j DNAT --to 1.1.1.1:53
ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to  2606:4700:4700::1111
ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to  2606:4700:4700::1001
ip6tables -t nat -I OUTPUT -p tcp --dport 53 -j DNAT --to  2606:4700:4700::1111
ip6tables -t nat -I OUTPUT -p udp --dport 53 -j DNAT --to  2606:4700:4700::1001

setprop net.eth0.dns1 1.1.1.1
setprop net.eth0.dns2 1.0.0.1
setprop net.dns1 1.1.1.1
setprop net.dns2 1.0.0.1
setprop net.ppp0.dns1 1.1.1.1
setprop net.ppp0.dns2 1.0.0.1
setprop net.rmnet0.dns1 1.1.1.1
setprop net.rmnet0.dns2 1.0.0.1
setprop net.rmnet1.dns1 1.1.1.1
setprop net.rmnet1.dns2 1.0.0.1
setprop net.rmnet2.dns1 1.1.1.1
setprop net.rmnet2.dns2 1.0.0.1
setprop net.pdpbr1.dns1 1.1.1.1
setprop net.pdpbr1.dns2 1.0.0.1
setprop net.wlan0.dns1 1.1.1.1
setprop net.wlan0.dns2 1.0.0.1
setprop 2606:4700:4700::1111
setprop 2606:4700:4700::1001

sendToLog "Changing DNS to CloudFlare"

sendToLog "DNS optimization is activated"
sendToLog "$divider";
}

dnsOptimizationGooglePublic() {
sendToLog "Activating DNS optimization..."

iptables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to 8.8.8.8:53
iptables -t nat -I OUTPUT -p udp --dport 53 -j DNAT --to 8.8.4.4:53
iptables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to 8.8.8.8:53
iptables -t nat -I OUTPUT -p tcp --dport 53 -j DNAT --to 8.8.4.4:53
ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to 2001:4860:4860:8888
ip6tables -t nat -I OUTPUT -p tcp --dport 53 -j DNAT --to 2001:4860:4860:8888
ip6tables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to 2001:4860:4860:8844
ip6tables -t nat -I OUTPUT -p udp --dport 53 -j DNAT --to 2001:4860:4860:8844

setprop net.eth0.dns1 8.8.8.8
setprop net.eth0.dns2 8.8.4.4
setprop net.dns1 8.8.8.8
setprop net.dns2 8.8.4.4
setprop net.ppp0.dns1 8.8.8.8
setprop net.ppp0.dns2 8.8.4.4
setprop net.rmnet0.dns1 8.8.8.8
setprop net.rmnet0.dns2 8.8.4.4
setprop net.rmnet1.dns1 8.8.8.8
setprop net.rmnet1.dns2 8.8.4.4
setprop net.rmnet2.dns1 8.8.8.8
setprop net.rmnet2.dns2 8.8.4.4
setprop net.pdpbr1.dns1 8.8.8.8
setprop net.pdpbr1.dns2 8.8.4.4
setprop net.wlan0.dns1 8.8.8.8
setprop net.wlan0.dns2 8.8.4.4
setprop 2001:4860:4860::8888
setprop 2001:4860:4860::8844

sendToLog "Changing DNS to Google Public"

sendToLog "DNS optimization is activated"
sendToLog "$divider";
}

netBuffersBig() {
sendToLog "Activating big net buffers..."

# Define TCP buffer sizes for various networks
# ReadMin, ReadInitial, ReadMax, WriteMin, WriteInitial, WriteMax
setprop net.tcp.buffersize.default 6144,87380,1048576,6144,87380,524288
setprop net.tcp.buffersize.wifi 524288,1048576,2097152,524288,1048576,2097152
setprop net.tcp.buffersize.umts 6144,87380,1048576,6144,87380,524288
setprop net.tcp.buffersize.gprs 6144,87380,1048576,6144,87380,524288
setprop net.tcp.buffersize.edge 6144,87380,524288,6144,16384,262144
setprop net.tcp.buffersize.hspa 6144,87380,524288,6144,16384,262144
setprop net.tcp.buffersize.lte 524288,1048576,2097152,524288,1048576,2097152
setprop net.tcp.buffersize.hsdpa 6144,87380,1048576,6144,87380,1048576
setprop net.tcp.buffersize.evdo_b 6144,87380,1048576,6144,87380,1048576

sendToLog "Big net buffers activated"
sendToLog "$divider";
}

netBuffersSmall() {
sendToLog "Activating small net buffers..."

# Define TCP buffer sizes for various networks
# ReadMin, ReadInitial, ReadMax, WriteMin, WriteInitial, WriteMax
setprop net.tcp.buffersize.hspa 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.umts 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.edge 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.gprs 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.hsdpa 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.wifi 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.evdo_b 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.lte 4096,32768,65536,4096,32768,65536
setprop net.tcp.buffersize.default 4096,32768,12582912,4096,32768,12582912

sendToLog "Small net buffers activated"
sendToLog "$divider";
}

netSpeedPlus() {
sendToLog "Activating Net Speed+..."

net=$($BUSYBOX ls -d /sys/class/net/*);
for i in $net; do
	if [ -e "$i"/tx_queue_len ]; then
		write "$i"/tx_queue_len "128"
		sendToLog "tx_queue_len=128 in $i";
	fi
done

#for i in $(ls /sys/class/net); do
#echo "1500" > /sys/class/net/"$i"/mtu
#echo "mtu=1500 in $i" >> $LOG;
#done

sendToLog "Net Speed+ activated"
sendToLog "$divider";
}

netTcpTweaks() {
sendToLog "Activating TCP tweak..."

#echo "128" > /proc/sys/net/core/netdev_max_backlog
#echo "0" > /proc/sys/net/core/netdev_tstamp_prequeue
#echo "0" > /proc/sys/net/ipv4/cipso_cache_bucket_size
#echo "0" > /proc/sys/net/ipv4/cipso_cache_enable
#echo "0" > /proc/sys/net/ipv4/cipso_rbm_strictvalid
#echo "0" > /proc/sys/net/ipv4/igmp_link_local_mcast_reports
#echo "24" > /proc/sys/net/ipv4/ipfrag_time
#echo "1" > /proc/sys/net/ipv4/tcp_ecn
#echo "0" > /proc/sys/net/ipv4/tcp_fwmark_accept
#echo "320" > /proc/sys/net/ipv4/tcp_keepalive_intvl
#echo "21600" > /proc/sys/net/ipv4/tcp_keepalive_time
#echo "1" > /proc/sys/net/ipv4/tcp_no_metrics_save
#echo "1800" > /proc/sys/net/ipv4/tcp_probe_interval
#echo "0" > /proc/sys/net/ipv4/tcp_slow_start_after_idle
#echo "48" > /proc/sys/net/ipv6/ip6frag_time

echo "0" > /proc/sys/net/ipv4/conf/default/secure_redirects
echo "0" > /proc/sys/net/ipv4/conf/default/accept_redirects
echo "0" > /proc/sys/net/ipv4/conf/default/accept_source_route
echo "0" > /proc/sys/net/ipv4/conf/all/secure_redirects
echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
echo "0" > /proc/sys/net/ipv4/ip_forward
echo "0" > /proc/sys/net/ipv4/ip_dynaddr
echo "0" > /proc/sys/net/ipv4/ip_no_pmtu_disc
echo "0" > /proc/sys/net/ipv4/tcp_ecn
echo "0" > /proc/sys/net/ipv4/tcp_timestamps
echo "1" > /proc/sys/net/ipv4/tcp_tw_reuse
echo "1" > /proc/sys/net/ipv4/tcp_fack
echo "1" > /proc/sys/net/ipv4/tcp_sack
echo "1" > /proc/sys/net/ipv4/tcp_dsack
echo "1" > /proc/sys/net/ipv4/tcp_rfc1337
echo "1" > /proc/sys/net/ipv4/tcp_tw_recycle
echo "1" > /proc/sys/net/ipv4/tcp_window_scaling
echo "1" > /proc/sys/net/ipv4/tcp_moderate_rcvbuf
echo "1" > /proc/sys/net/ipv4/tcp_no_metrics_save
echo "2" > /proc/sys/net/ipv4/tcp_synack_retries
echo "2" > /proc/sys/net/ipv4/tcp_syn_retries
echo "5" > /proc/sys/net/ipv4/tcp_keepalive_probes
echo "30" > /proc/sys/net/ipv4/tcp_keepalive_intvl
echo "30" > /proc/sys/net/ipv4/tcp_fin_timeout
echo "1800" > /proc/sys/net/ipv4/tcp_keepalive_time
echo "261120" > /proc/sys/net/core/rmem_max
echo "261120" > /proc/sys/net/core/wmem_max
echo "261120" > /proc/sys/net/core/rmem_default
echo "261120" > /proc/sys/net/core/wmem_default

sendToLog "TCP tweak activated"
sendToLog "$divider";
}

rilTweaks() {
sendToLog "Activating ril tweaks..."

resetprop ro.ril.gprsclass 12
sendToLog "GPRS Class changed to 12"

resetprop ro.ril.hsdpa.category 28
sendToLog "hsdpa category changed to 28"

resetprop ro.ril.hsupa.category 7
sendToLog "hsupa category changed to 7"

resetprop ro.telephony.call_ring.delay 1500
sendToLog "RING/CRING event delay reduced to 1.5sec"

resetprop ro.telephony.call_ring.multiple false
sendToLog "Ril sends only one RIL_UNSOL_CALL_RING, so set call_ring.multiple to false"

sendToLog "Ril tweaks are activated"
sendToLog "$divider";
}

disableDebugging() {
sendToLog "Powerful logging disable started..."

$BUSYBOX find /sys -name debug_mask |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

$BUSYBOX find /sys -name debug |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

$BUSYBOX find /sys -name debug_enabled |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

$BUSYBOX find /sys -name debug_level |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

$BUSYBOX find /sys -name edac_mc_log_ce |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

$BUSYBOX find /sys -name edac_mc_log_ue |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

find /sys -name enable_event_log |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

$BUSYBOX find /sys -name log_ecn_error |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

$BUSYBOX find /sys -name snapshot_crashdumper |
while read -r fileName
	do
		write "$fileName" "0"
		sendToLog "Disabled debugging for $fileName"  
done

console_suspend=/sys/module/printk/parameters/console_suspend
if [ -e $console_suspend ]; then
	write $console_suspend "Y"
	sendToLog "Console suspended"
fi;

log_mode=/sys/module/logger/parameters/log_mode
if [ -e $log_mode ]; then
	write $log_mode "2"
	sendToLog "Logger disabled"
fi;

debug_enabled=/sys/kernel/debug/debug_enabled
if [ -e $debug_enabled ]; then
	write $debug_enabled "N"
	sendToLog "Disabled kernel debugging"
fi;

exception_trace=/proc/sys/debug/exception-trace
if [ -e "$exception_trace" ]; then
	write $exception_trace "0"
	sendToLog "Disabled exception-trace debugger"
fi;

mali_debug_level=/sys/module/mali/parameters/mali_debug_level
if [ -e $mali_debug_level ]; then
	write $mali_debug_level "0"
	sendToLog "Disabled mali GPU debugging"
fi;

block_dump=/proc/sys/vm/block_dump
if [ -e $block_dump ]; then
	write $block_dump "0"
	sendToLog "Disabled I/O block debugging"
fi;

mballoc_debug=/sys/module/ext4/parameters/mballoc_debug
if [ -e $mballoc_debug ]; then
	write $mballoc_debug "0"
	sendToLog "Disabled ext4 runtime debugging"
fi;

logger_mode=/sys/kernel/logger_mode/logger_mode
if [ -e $logger_mode ]; then
	write $logger_mode "0"
	sendToLog "Disabled $logger_mode"
fi;

log_enabled=/sys/module/logger/parameters/log_enabled
if [ -e $log_enabled ]; then
	write $log_enabled "0"
	sendToLog "Disabled $log_enabled"
fi;

logger_enabled=/sys/module/logger/parameters/enabled
if [ -e $logger_enabled ]; then
	write $logger_enabled "0"
	sendToLog "Disabled $logger_enabled"
fi;

compat_log=/proc/sys/kernel/compat-log
if [ -e $compat_log ]; then
	write $compat_log "0"
	sendToLog "Compat logging disabled"
fi;

disable_ertm=/sys/module/bluetooth/parameters/disable_ertm
if [ -e $disable_ertm ]; then
	write $disable_ertm "0"
	sendToLog "Bluetooth ertm disabled"
fi;

disable_esco=/sys/module/bluetooth/parameters/disable_esco
if [ -e $disable_esco ]; then
	write $disable_esco "0"
	sendToLog "Bluetooth esco is disabled"
fi;

sendToLog "Logging disabled..."
sendToLog "$divider";
}

disableKernelPanic() {
sendToLog "Disabling kernel panic..."

	$BUSYBOX sysctl -e -w vm.panic_on_oom=0
	$BUSYBOX sysctl -e -w kernel.panic_on_oops=0
	$BUSYBOX sysctl -e -w kernel.panic=0
	$BUSYBOX sysctl -e -w kernel.panic_on_warn=0

sendToLog "Kernel panic disabled"
sendToLog "$divider";
}

selinux() {
	sendToLog "Changing selinux..."

	setenforce $1
	
	selinuxState=$(cat /sys/fs/selinux/enforce)

	if [ $1 -eq $selinuxState ]; then
		if [ $selinuxState -eq 0 ]; then
			sendToLog "Selinux changed to permissive"
		elif [ $selinuxState -eq 1 ]; then
			sendToLog "Selinux changed to enforcing"
		fi
	else
		sendToLog "Unable to change selinux mode"
	fi

	sendToLog "$divider"
}

disableMultitaskingLimitations() {
sendToLog "Disabling multitasking limitations..."

setprop MIN_HIDDEN_APPS false
sendToLog "MIN_HIDDEN_APPS=false"

setprop ACTIVITY_INACTIVE_RESET_TIME false
sendToLog "ACTIVITY_INACTIVE_RESET_TIME=false"

setprop MIN_RECENT_TASKS false
sendToLog "MIN_RECENT_TASKS=false"

setprop PROC_START_TIMEOUT false
sendToLog "PROC_START_TIMEOUT=false"

setprop CPU_MIN_CHECK_DURATION false
sendToLog "CPU_MIN_CHECK_DURATION=false"

setprop GC_TIMEOUT false
sendToLog "GC_TIMEOUT=false"

setprop SERVICE_TIMEOUT false
sendToLog "SERVICE_TIMEOUT=false"

setprop MIN_CRASH_INTERVAL false
sendToLog "MIN_CRASH_INTERVAL=false"

setprop ENFORCE_PROCESS_LIMIT false
sendToLog "ENFORCE_PROCESS_LIMIT=false"

sendToLog "Multitasking limitations disabled"
sendToLog "$divider";
}

lowRamFlagDisabled() {
sendToLog "Disabling low RAM flag..."

resetprop ro.config.low_ram false

sendToLog "Low RAM flag disabled"
sendToLog "$divider";
}

lowRamFlagEnabled() {
sendToLog "Enabling low RAM flag..."

resetprop ro.config.low_ram true

sendToLog "Low RAM flag enabled"
sendToLog "$divider";
}

oomKillerDisabled() {
sendToLog "Disabled OOM killer..."

oom_kill_allocating_task=/proc/sys/vm/oom_kill_allocating_task
if [ -e $oom_kill_allocating_task ]; then
	write $oom_kill_allocating_task "0"
fi;

sendToLog "OOM killer disabled"
sendToLog "$divider";
}

oomKillerEnabled() {
sendToLog "Enabling OOM killer..."

oom_kill_allocating_task=/proc/sys/vm/oom_kill_allocating_task
if [ -e $oom_kill_allocating_task ]; then
	write $oom_kill_allocating_task "1"
fi;

sendToLog "OOM killer enabled"
sendToLog "$divider";
}

ramManagerBalanced() {

fa=$(((memTotal*5/2/100)*1024/4));
va=$(((memTotal*3/100)*1024/4));
ss=$(((memTotal*5/100)*1024/4));
ha=$(((memTotal*7/100)*1024/4));
cp=$(((memTotal*9/100)*1024/4));
ea=$(((memTotal*11/100)*1024/4));
minFree="$fa,$va,$ss,$ha,$cp,$ea";

# Higher values of oom_adj are more likely
# to be killed by the kernel's oom killer.
# The current foreground app has a oom_adj of 0
adj="0,112,224,408,824,1000";

# If you set this to lower than 1024KB, your system will
# become subtly broken, and prone to deadlock under high loads, we don't allow it below 3072kb
mfk=$((memTotal*9/5));

if [ "$mfk" -le "3072" ]; then
mfk=3072;
fi;

# Extra free kbytes calculated based on min_free_kbytes
efk=$((mfk*16/5));

if [ "$efk" -le 18432 ]; then
	efk=18432;
fi;

# Background app limit per ram size
if [ "$memTotal" -le "1024" ]; then
	backgroundAppLimit="24";
elif [ "$memTotal" -le "2048" ]; then
	backgroundAppLimit="28";
elif [ "$memTotal" -le "3072" ]; then
	backgroundAppLimit="30";
elif [ "$memTotal" -le "4096" ]; then
	backgroundAppLimit="36";
else
	backgroundAppLimit="42";
fi;

# Set 1 to reclaim resources quickly when needed.
fastRun="0";

oomReaper="1";
adaptiveLmk="0";

# How much memory of swap will be counted as free
fudgeSwap="1024";


sendToLog "Enabling balanced RAM manager profile"

sync
$BUSYBOX sysctl -w vm.drop_caches=3;

resetprop ro.sys.fw.bg_apps_limit $backgroundAppLimit;
resetprop ro.vendor.qti.sys.fw.bg_apps_limit $backgroundAppLimit;
sendToLog "Background app limit=$backgroundAppLimit"

parameter_adj=/sys/module/lowmemorykiller/parameters/adj;
if [ -e $parameter_adj ]; then
	write $parameter_adj "$adj"
	sendToLog "adj=$adj"
fi;

parameter_oom_reaper=/sys/module/lowmemorykiller/parameters/oom_reaper;
if [ -e $parameter_oom_reaper ]; then
	write $parameter_oom_reaper "$oomReaper"
	sendToLog "oom_reaper=$oomReaper"
fi;

parameter_lmk_fast_run=/sys/module/lowmemorykiller/parameters/lmk_fast_run;
if [ -e $parameter_lmk_fast_run ]; then
	write $parameter_lmk_fast_run "$fastRun"
	sendToLog "lmk_fast_run=$fastRun"
fi;

parameter_adaptive_lmk=/sys/module/lowmemorykiller/parameters/enable_adaptive_lmk;
if [ -e $parameter_adaptive_lmk ]; then
	write $parameter_adaptive_lmk "$adaptiveLmk"
	setprop lmk.autocalc false;
	sendToLog "adaptive_lmk=$adaptiveLmk"
fi;

parameter_fudge_swap=/sys/module/lowmemorykiller/parameters/fudgeswap;
if [ -e $parameter_fudge_swap ]; then
	write $parameter_fudge_swap "$fudgeSwap"
	sendToLog "fudge_swap=$fudgeSwap"
fi;

parameter_minfree=/sys/module/lowmemorykiller/parameters/minfree;
if [ -e $parameter_minfree ]; then
	write $parameter_minfree "$minFree"
	sendToLog "minfree=$minFree"
fi;

parameter_min_free_kbytes=/proc/sys/vm/min_free_kbytes;
if [ -e $parameter_min_free_kbytes ]; then
	write $parameter_min_free_kbytes "$mfk"
	sendToLog "min_free_kbytes=$mfk"
fi;

parameter_extra_free_kbytes=/proc/sys/vm/extra_free_kbytes;
if [ -e $parameter_extra_free_kbytes ]; then
	write $parameter_extra_free_kbytes "$efk"
	sendToLog "extra_free_kbytes=$efk"
fi;

sendToLog "Balanced RAM manager profile for $((memTotal))mb devices successfully applied"
sendToLog "$divider";
}

ramManagerGaming() {

fa=$(((memTotal*3/2/100)*1024/4));
va=$(((memTotal*2/100)*1024/4));
ss=$(((memTotal*4/100)*1024/4));
ha=$(((memTotal*7/100)*1024/4));
cp=$(((memTotal*11/100)*1024/4));
ea=$(((memTotal*15/100)*1024/4));
minFree="$fa,$va,$ss,$ha,$cp,$ea";

# Higher values of oom_adj are more likely
# to be killed by the kernel's oom killer.
# The current foreground app has a oom_adj of 0
adj="0,112,224,408,824,1000";

# If you set this to lower than 1024KB, your system will
# become subtly broken, and prone to deadlock under high loads, we don't allow it below 3072kb
mfk=$((memTotal*9/5));

if [ "$mfk" -le "3072" ]; then
mfk=3072;
fi;

# Extra free kbytes calculated based on min_free_kbytes
efk=$((mfk*16/5));

if [ "$efk" -le 18432 ]; then
	efk=18432;
fi;

# Background app limit per ram size
if [ "$memTotal" -le "1024" ]; then
	backgroundAppLimit="18";
elif [ "$memTotal" -le "2048" ]; then
	backgroundAppLimit="22";
elif [ "$memTotal" -le "3072" ]; then
	backgroundAppLimit="26";
elif [ "$memTotal" -le "4096" ]; then
	backgroundAppLimit="30";
else
	backgroundAppLimit="42";
fi;

# Set 1 to reclaim resources quickly when needed.
fastRun="1";

oomReaper="1";
adaptiveLmk="0";

# How much memory of swap will be counted as free
fudgeSwap="1024";


sendToLog "Enabling gaming RAM manager profile"

sync
$BUSYBOX sysctl -w vm.drop_caches=3;

resetprop ro.sys.fw.bg_apps_limit $backgroundAppLimit;
resetprop ro.vendor.qti.sys.fw.bg_apps_limit $backgroundAppLimit;
sendToLog "Background app limit=$backgroundAppLimit"

parameter_adj=/sys/module/lowmemorykiller/parameters/adj;
if [ -e $parameter_adj ]; then
	write $parameter_adj "$adj"
	sendToLog "adj=$adj"
fi;

parameter_oom_reaper=/sys/module/lowmemorykiller/parameters/oom_reaper;
if [ -e $parameter_oom_reaper ]; then
	write $parameter_oom_reaper "$oomReaper"
	sendToLog "oom_reaper=$oomReaper"
fi;

parameter_lmk_fast_run=/sys/module/lowmemorykiller/parameters/lmk_fast_run;
if [ -e $parameter_lmk_fast_run ]; then
	write $parameter_lmk_fast_run "$fastRun"
	sendToLog "lmk_fast_run=$fastRun"
fi;

parameter_adaptive_lmk=/sys/module/lowmemorykiller/parameters/enable_adaptive_lmk;
if [ -e $parameter_adaptive_lmk ]; then
	write $parameter_adaptive_lmk "$adaptiveLmk"
	setprop lmk.autocalc false;
	sendToLog "adaptive_lmk=$adaptiveLmk"
fi;

parameter_fudge_swap=/sys/module/lowmemorykiller/parameters/fudgeswap;
if [ -e $parameter_fudge_swap ]; then
	write $parameter_fudge_swap "$fudgeSwap"
	sendToLog "fudge_swap=$fudgeSwap"
fi;

parameter_minfree=/sys/module/lowmemorykiller/parameters/minfree;
if [ -e $parameter_minfree ]; then
	write $parameter_minfree "$minFree"
	sendToLog "minfree=$minFree"
fi;

parameter_min_free_kbytes=/proc/sys/vm/min_free_kbytes;
if [ -e $parameter_min_free_kbytes ]; then
	write $parameter_min_free_kbytes "$mfk"
	sendToLog "min_free_kbytes=$mfk"
fi;

parameter_extra_free_kbytes=/proc/sys/vm/extra_free_kbytes;
if [ -e $parameter_extra_free_kbytes ]; then
	write $parameter_extra_free_kbytes "$efk"
	sendToLog "extra_free_kbytes=$efk"
fi;

sendToLog "Gaming RAM manager profile for $((memTotal))mb devices successfully applied"
sendToLog "$divider";
}

ramManagerMultitasking() {

fa=$(((memTotal*2/100)*1024/4));
va=$(((memTotal*3/100)*1024/4));
ss=$(((memTotal*4/100)*1024/4));
ha=$(((memTotal*6/100)*1024/4));
cp=$(((memTotal*9/100)*1024/4));
ea=$(((memTotal*12/100)*1024/4));
minFree="$fa,$va,$ss,$ha,$cp,$ea";

# Higher values of oom_adj are more likely
# to be killed by the kernel's oom killer.
# The current foreground app has a oom_adj of 0
adj="0,112,224,408,824,1000";

# If you set this to lower than 1024KB, your system will
# become subtly broken, and prone to deadlock under high loads, we don't allow it below 3072kb
mfk=$((memTotal*9/5));

if [ "$mfk" -le "3072" ]; then
mfk=3072;
fi;

# Extra free kbytes calculated based on min_free_kbytes
efk=$((mfk*16/5));

if [ "$efk" -le 18432 ]; then
	efk=18432;
fi;

# Background app limit per ram size
if [ "$memTotal" -le "1024" ]; then
	backgroundAppLimit="25";
elif [ "$memTotal" -le "2048" ]; then
	backgroundAppLimit="30";
elif [ "$memTotal" -le "3072" ]; then
	backgroundAppLimit="36";
elif [ "$memTotal" -le "4096" ]; then
	backgroundAppLimit="42";
else
	backgroundAppLimit="44";
fi;

# Set 1 to reclaim resources quickly when needed.
fastRun="0";

oomReaper="1";
adaptiveLmk="0";

# How much memory of swap will be counted as free
fudgeSwap="1024";


sendToLog "Enabling multitasking RAM manager profile"

sync
$BUSYBOX sysctl -w vm.drop_caches=3;

resetprop ro.sys.fw.bg_apps_limit $backgroundAppLimit;
resetprop ro.vendor.qti.sys.fw.bg_apps_limit $backgroundAppLimit;
sendToLog "Background app limit=$backgroundAppLimit"

parameter_adj=/sys/module/lowmemorykiller/parameters/adj;
if [ -e $parameter_adj ]; then
	write $parameter_adj "$adj"
	sendToLog "adj=$adj"
fi;

parameter_oom_reaper=/sys/module/lowmemorykiller/parameters/oom_reaper;
if [ -e $parameter_oom_reaper ]; then
	write $parameter_oom_reaper "$oomReaper"
	sendToLog "oom_reaper=$oomReaper"
fi;

parameter_lmk_fast_run=/sys/module/lowmemorykiller/parameters/lmk_fast_run;
if [ -e $parameter_lmk_fast_run ]; then
	write $parameter_lmk_fast_run "$fastRun"
	sendToLog "lmk_fast_run=$fastRun"
fi;

parameter_adaptive_lmk=/sys/module/lowmemorykiller/parameters/enable_adaptive_lmk;
if [ -e $parameter_adaptive_lmk ]; then
	write $parameter_adaptive_lmk "$adaptiveLmk"
	setprop lmk.autocalc false;
	sendToLog "adaptive_lmk=$adaptiveLmk"
fi;

parameter_fudge_swap=/sys/module/lowmemorykiller/parameters/fudgeswap;
if [ -e $parameter_fudge_swap ]; then
	write $parameter_fudge_swap "$fudgeSwap"
	sendToLog "fudge_swap=$fudgeSwap"
fi;

parameter_minfree=/sys/module/lowmemorykiller/parameters/minfree;
if [ -e $parameter_minfree ]; then
	write $parameter_minfree "$minFree"
	sendToLog "minfree=$minFree"
fi;

parameter_min_free_kbytes=/proc/sys/vm/min_free_kbytes;
if [ -e $parameter_min_free_kbytes ]; then
	write $parameter_min_free_kbytes "$mfk"
	sendToLog "min_free_kbytes=$mfk"
fi;

parameter_extra_free_kbytes=/proc/sys/vm/extra_free_kbytes;
if [ -e $parameter_extra_free_kbytes ]; then
	write $parameter_extra_free_kbytes "$efk"
	sendToLog "extra_free_kbytes=$efk"
fi;

sendToLog "Multitasking RAM manager profile for $((memTotal))mb devices successfully applied"
sendToLog "$divider";
}

swappinessTendency() {
	sendToLog "Setting swappiness tendency...";

	swappiness=/proc/sys/vm/swappiness
	if [ -e $swappiness ]; then
		if [ "$1" = "1" ]; then
			write $swappiness "1"
			
			sendToLog "swappiness=1";
			sendToLog "Swappiness tendency set to 1";
		elif [ "$1" = "2" ]; then
			write $swappiness "10"
			
			sendToLog "swappiness=10";
			sendToLog "Swappiness tendency set to 10";
			
		elif [ "$1" = "3" ]; then
			write $swappiness "25"
			
			sendToLog "swappiness=25";
			sendToLog "Swappiness tendency set to 25";
			
		elif [ "$1" = "4" ]; then
			write $swappiness "50"
			
			sendToLog "swappiness=50";
			sendToLog "Swappiness tendency set to 50";

		elif [ "$1" = "5" ]; then
			write $swappiness "75"
			
			sendToLog "swappiness=75";
			sendToLog "Swappiness tendency set to 75";

		elif [ "$1" = "6" ]; then
			write $swappiness "100"
			
			sendToLog "swappiness=100";
			sendToLog "Swappiness tendency set to 100";			
		fi
	fi;
	sendToLog "$divider";
}

virtualMemoryTweaksBalanced() {
sendToLog "Activating balanced virtual memory tweaks..."

sync

leases_enable=/proc/sys/fs/leases-enable
if [ -e $leases_enable ]; then
	write $leases_enable "1"		
	sendToLog "leases_enable=1"
fi;

# This file specifies the grace period (in seconds) that the kernel grants
# to a process holding a file lease after it has sent a signal to that process
# notifying it that another process is waiting to open the file.
# If the lease holder does not remove or downgrade the lease within this grace period,
# the kernel forcibly breaks the lease.
lease_break_time=/proc/sys/fs/lease-break-time
if [ -e $lease_break_time ]; then
	write $lease_break_time "20"		
	sendToLog "lease_break_time=20"
fi;

# dnotify is a signal used to notify a process about file/directory changes.
dir_notify_enable=/proc/sys/fs/dir-notify-enable
if [ -e $dir_notify_enable ]; then
	write $dir_notify_enable "0"		
	sendToLog "dir_notify_enable=0"
fi;

sendToLog "File system parameters are updated"

enable_process_reclaim=/sys/module/process_reclaim/parameters/enable_process_reclaim
if [ -e $enable_process_reclaim ]; then
	write $enable_process_reclaim "0"		
	sendToLog "Reclaiming pages of inactive tasks disabled"
fi;

# This parameter tells how much of physical RAM to take when swap is full
overcommit_ratio=/proc/sys/vm/overcommit_ratio
if [ -e overcommit_ratio ]; then
	write $overcommit_ratio "0"		
	sendToLog "overcommit_ratio=0"
fi;

oom_dump_tasks=/proc/sys/vm/oom_dump_tasks
if [ -e $oom_dump_tasks ]; then
	write $oom_dump_tasks "0"		
	sendToLog "OOM dump tasks are disabled"
fi;

vfs_cache_pressure=/proc/sys/vm/vfs_cache_pressure
if [ -e $vfs_cache_pressure ]; then
	write $vfs_cache_pressure "60"		
	sendToLog "vfs_cache_pressure=60"
fi;

laptop_mode=/proc/sys/vm/laptop_mode
if [ -e $laptop_mode ]; then
	write $laptop_mode "0"		
	sendToLog "laptop_mode=0"
fi;

# page-cluster controls the number of pages up to which consecutive pages
# are read in from swap in a single attempt. This is the swap counterpart
# to page cache readahead.
# The mentioned consecutivity is not in terms of virtual/physical addresses,
# but consecutive on swap space - that means they were swapped out together.
# It is a logarithmic value - setting it to zero means "1 page", setting
# it to 1 means "2 pages", setting it to 2 means "4 pages", etc.
# Zero disables swap readahead completely.
# The default value is three (eight pages at a time).  There may be some
# small benefits in tuning this to a different value if your workload is
# swap-intensive.
# Lower values mean lower latencies for initial faults, but at the same time
# extra faults and I/O delays for following faults if they would have been part of
# that consecutive pages readahead would have brought in.
page_cluster=/proc/sys/vm/page-cluster
if [ -e $page_cluster ]; then
	write $page_cluster "0"		
	sendToLog "page_cluster=0"
fi;

# vm.dirty_expire_centisecs is how long something can be in cache
# before it needs to be written.
# When the pdflush/flush/kdmflush processes kick in they will
# check to see how old a dirty page is, and if its older than this value itll
# be written asynchronously to disk. Since holding a dirty page in memory is
# unsafe this is also a safeguard against data loss.
dirty_expire_centisecs=/proc/sys/vm/dirty_expire_centisecs
if [ -e $dirty_expire_centisecs ]; then
	write $dirty_expire_centisecs "300"		
	sendToLog "dirty_expire_centisecs=300"
fi;

# vm.dirty_writeback_centisecs is how often the pdflush/flush/kdmflush processes wake up
# and check to see if work needs to be done.
dirty_writeback_centisecs=/proc/sys/vm/dirty_writeback_centisecs
if [ -e $dirty_writeback_centisecs ]; then
	write $dirty_writeback_centisecs "700"		
	sendToLog "dirty_writeback_centisecs=700"
fi;

# vm.dirty_background_ratio is the percentage of system memory(RAM)
# that can be filled with dirty pages  memory pages that
# still need to be written to disk  before the pdflush/flush/kdmflush
# background processes kick in to write it to disk.
# It can be 50% or less of dirtyRatio
# If ( dirty_background_ratio >= dirty_ratio ) {
# dirty_background_ratio = dirty_ratio / 2 (or 4)
dirty_background_ratio=/proc/sys/vm/dirty_background_ratio
if [ -e $dirty_background_ratio ]; then
	write $dirty_background_ratio "5"		
	sendToLog "dirty_background_ratio=5"
fi;

# vm.dirty_ratio is the absolute maximum amount of system memory
# that can be filled with dirty pages before everything must get committed to disk.
# When the system gets to this point all new I/O blocks until dirty pages
# have been written to disk. This is often the source of long I/O pauses,
# but is a safeguard against too much data being cached unsafely in memory.
dirty_ratio=/proc/sys/vm/dirty_ratio
if [ -e $dirty_ratio ]; then
	write $dirty_ratio "25"		
	sendToLog "dirty_ratio=25"
fi;

sendToLog "Balanced virtual memory tweaks activated"
sendToLog "$divider";
}

virtualMemoryTweaksBattery() {
sendToLog "Activating battery virtual memory tweaks..."

sync

leases_enable=/proc/sys/fs/leases-enable
if [ -e $leases_enable ]; then
	write $leases_enable "1"		
	sendToLog "leases_enable=1"
fi;

# This file specifies the grace period (in seconds) that the kernel grants
# to a process holding a file lease after it has sent a signal to that process
# notifying it that another process is waiting to open the file.
# If the lease holder does not remove or downgrade the lease within this grace period,
# the kernel forcibly breaks the lease.

lease_break_time=/proc/sys/fs/lease-break-time
if [ -e $lease_break_time ]; then
	write $lease_break_time "20"		
	sendToLog "lease_break_time=20"
fi;

# dnotify is a signal used to notify a process about file/directory changes.
dir_notify_enable=/proc/sys/fs/dir-notify-enable
if [ -e $dir_notify_enable ]; then
	write $dir_notify_enable "0"		
	sendToLog "dir_notify_enable=0"
fi;

sendToLog "File system parameters are updated"

enable_process_reclaim=/sys/module/process_reclaim/parameters/enable_process_reclaim
if [ -e $enable_process_reclaim ]; then
	write $enable_process_reclaim "0"		
	sendToLog "Reclaiming pages of inactive tasks disabled"
fi;

# This parameter tells how much of physical RAM to take when swap is full
overcommit_ratio=/proc/sys/vm/overcommit_ratio
if [ -e overcommit_ratio ]; then
	write $overcommit_ratio "0"		
	sendToLog "overcommit_ratio=0"
fi;

oom_dump_tasks=/proc/sys/vm/oom_dump_tasks
if [ -e $oom_dump_tasks ]; then
	write $oom_dump_tasks "0"		
	sendToLog "OOM dump tasks are disabled"
fi;

vfs_cache_pressure=/proc/sys/vm/vfs_cache_pressure
if [ -e $vfs_cache_pressure ]; then
	write $vfs_cache_pressure "40"		
	sendToLog "vfs_cache_pressure=40"
fi;

laptop_mode=/proc/sys/vm/laptop_mode
if [ -e $laptop_mode ]; then
	write $laptop_mode "0"		
	sendToLog "laptop_mode=0"
fi;

# page-cluster controls the number of pages up to which consecutive pages
# are read in from swap in a single attempt. This is the swap counterpart
# to page cache readahead.
# The mentioned consecutivity is not in terms of virtual/physical addresses,
# but consecutive on swap space - that means they were swapped out together.
# It is a logarithmic value - setting it to zero means "1 page", setting
# it to 1 means "2 pages", setting it to 2 means "4 pages", etc.
# Zero disables swap readahead completely.
# The default value is three (eight pages at a time).  There may be some
# small benefits in tuning this to a different value if your workload is
# swap-intensive.
# Lower values mean lower latencies for initial faults, but at the same time
# extra faults and I/O delays for following faults if they would have been part of
# that consecutive pages readahead would have brought in.
page_cluster=/proc/sys/vm/page-cluster
if [ -e $page_cluster ]; then
	write $page_cluster "0"		
	sendToLog "page_cluster=0"
fi;

# vm.dirty_expire_centisecs is how long something can be in cache
# before it needs to be written.
# When the pdflush/flush/kdmflush processes kick in they will
# check to see how old a dirty page is, and if its older than this value itll
# be written asynchronously to disk. Since holding a dirty page in memory is
# unsafe this is also a safeguard against data loss.
dirty_expire_centisecs=/proc/sys/vm/dirty_expire_centisecs
if [ -e $dirty_expire_centisecs ]; then
	write $dirty_expire_centisecs "500"		
	sendToLog "dirty_expire_centisecs=500"
fi;

# vm.dirty_writeback_centisecs is how often the pdflush/flush/kdmflush processes wake up
# and check to see if work needs to be done.
dirty_writeback_centisecs=/proc/sys/vm/dirty_writeback_centisecs
if [ -e $dirty_writeback_centisecs ]; then
	write $dirty_writeback_centisecs "1000"		
	sendToLog "dirty_writeback_centisecs=1000"
fi;

# vm.dirty_background_ratio is the percentage of system memory(RAM)
# that can be filled with dirty pages  memory pages that
# still need to be written to disk  before the pdflush/flush/kdmflush
# background processes kick in to write it to disk.
# It can be 50% or less of dirtyRatio
# If ( dirty_background_ratio >= dirty_ratio ) {
# dirty_background_ratio = dirty_ratio / 2 (or 4)
dirty_background_ratio=/proc/sys/vm/dirty_background_ratio
if [ -e $dirty_background_ratio ]; then
	write $dirty_background_ratio "5"		
	sendToLog "dirty_background_ratio=5"
fi;

# vm.dirty_ratio is the absolute maximum amount of system memory
# that can be filled with dirty pages before everything must get committed to disk.
# When the system gets to this point all new I/O blocks until dirty pages
# have been written to disk. This is often the source of long I/O pauses,
# but is a safeguard against too much data being cached unsafely in memory.
dirty_ratio=/proc/sys/vm/dirty_ratio
if [ -e $dirty_ratio ]; then
	write $dirty_ratio "30"		
	sendToLog "dirty_ratio=30"
fi;

sendToLog "Battery virtual memory tweaks activated"
sendToLog "$divider";
}

virtualMemoryTweaksPerformance() {
sendToLog "Activating performance virtual memory tweaks..."

sync

leases_enable=/proc/sys/fs/leases-enable
if [ -e $leases_enable ]; then
	write $leases_enable "1"
	sendToLog "leases_enable=1"
fi;

# This file specifies the grace period (in seconds) that the kernel grants
# to a process holding a file lease after it has sent a signal to that process
# notifying it that another process is waiting to open the file.
# If the lease holder does not remove or downgrade the lease within this grace period,
# the kernel forcibly breaks the lease.

lease_break_time=/proc/sys/fs/lease-break-time
if [ -e $lease_break_time ]; then
	write $lease_break_time "20"
	sendToLog "lease_break_time=20"
fi;

# dnotify is a signal used to notify a process about file/directory changes.
dir_notify_enable=/proc/sys/fs/dir-notify-enable
if [ -e $dir_notify_enable ]; then
	write $dir_notify_enable "0"
	sendToLog "dir_notify_enable=0"
fi;

sendToLog "File system parameters are updated"

enable_process_reclaim=/sys/module/process_reclaim/parameters/enable_process_reclaim
if [ -e $enable_process_reclaim ]; then
	write $enable_process_reclaim "0"
	sendToLog "Reclaiming pages of inactive tasks disabled"
fi;

# This parameter tells how much of physical RAM to take when swap is full
overcommit_ratio=/proc/sys/vm/overcommit_ratio
if [ -e $overcommit_ratio ]; then
	write $overcommit_ratio "0"
	sendToLog "overcommit_ratio=0"
fi;

oom_dump_tasks=/proc/sys/vm/oom_dump_tasks
if [ -e $oom_dump_tasks ]; then
	write $oom_dump_tasks "0"
	sendToLog "oom_dump_tasks=0"
fi;

vfs_cache_pressure=/proc/sys/vm/vfs_cache_pressure
if [ -e $vfs_cache_pressure ]; then
	write $vfs_cache_pressure "100"
	sendToLog "vfs_cache_pressure=100"
fi;

laptop_mode=/proc/sys/vm/laptop_mode
if [ -e $laptop_mode ]; then
	write $laptop_mode "0"
	sendToLog "laptop_mode=0"
fi;

# page-cluster controls the number of pages up to which consecutive pages
# are read in from swap in a single attempt. This is the swap counterpart
# to page cache readahead.
# The mentioned consecutivity is not in terms of virtual/physical addresses,
# but consecutive on swap space - that means they were swapped out together.
# It is a logarithmic value - setting it to zero means "1 page", setting
# it to 1 means "2 pages", setting it to 2 means "4 pages", etc.
# Zero disables swap readahead completely.
# The default value is three (eight pages at a time).  There may be some
# small benefits in tuning this to a different value if your workload is
# swap-intensive.
# Lower values mean lower latencies for initial faults, but at the same time
# extra faults and I/O delays for following faults if they would have been part of
# that consecutive pages readahead would have brought in.
page_cluster=/proc/sys/vm/page-cluster
if [ -e $page_cluster ]; then
	write $page_cluster "0"
	sendToLog "page_cluster=0"
fi;

# vm.dirty_expire_centisecs is how long something can be in cache
# before it needs to be written.
# When the pdflush/flush/kdmflush processes kick in they will
# check to see how old a dirty page is, and if its older than this value itll
# be written asynchronously to disk. Since holding a dirty page in memory is
# unsafe this is also a safeguard against data loss.
dirty_expire_centisecs=/proc/sys/vm/dirty_expire_centisecs
if [ -e $dirty_expire_centisecs ]; then
	write $dirty_expire_centisecs "250"
	sendToLog "dirty_expire_centisecs=250"
fi;

# vm.dirty_writeback_centisecs is how often the pdflush/flush/kdmflush processes wake up
# and check to see if work needs to be done.
dirty_writeback_centisecs=/proc/sys/vm/dirty_writeback_centisecs
if [ -e $dirty_writeback_centisecs ]; then
	write $dirty_writeback_centisecs "700"
	sendToLog "dirty_writeback_centisecs=700"
fi;

# vm.dirty_background_ratio is the percentage of system memory(RAM)
# that can be filled with dirty pages  memory pages that
# still need to be written to disk  before the pdflush/flush/kdmflush
# background processes kick in to write it to disk.
# It can be 50% or less of dirtyRatio
# If ( dirty_background_ratio >= dirty_ratio ) {
# dirty_background_ratio = dirty_ratio / 2 (or 4)
dirty_background_ratio=/proc/sys/vm/dirty_background_ratio
if [ -e $dirty_background_ratio ]; then
	write $dirty_background_ratio "5"
	sendToLog "dirty_background_ratio=5"
fi;

# vm.dirty_ratio is the absolute maximum amount of system memory
# that can be filled with dirty pages before everything must get committed to disk.
# When the system gets to this point all new I/O blocks until dirty pages
# have been written to disk. This is often the source of long I/O pauses,
# but is a safeguard against too much data being cached unsafely in memory.
dirty_ratio=/proc/sys/vm/dirty_ratio
if [ -e $dirty_ratio ]; then
	write $dirty_ratio "10"
	sendToLog "dirty_ratio=10"
fi;

sendToLog "Performance virtual memory tweaks activated"
sendToLog "$divider";
}

heapOptimization() {
heapSize=$((memTotal*3/16));

# Don't use more than 512mb
if [ "$heapSize" -gt "512" ]; then
	heapSize=512;
fi

heapGrowthLimit=$((heapSize*5/11));

sendToLog "Activating heap optimization";

# The ideal ratio of live to free memory. It's good to have a value between 0.2 and 0.9.
# This limit the managed hepSize to heapsize*heaptargetutilization so it won't be full every time
setprop dalvik.vm.heaptargetutilization 0.80
sendToLog "heapTargetUtilization=0.80";

# This is the heap size that Dalvik/ART assigns to every new large App.
# Large Apps are the ones that include the android:largeHeap option in their manifest.
# Note that many apps abuse this option, in an effort to increase their performance.
setprop dalvik.vm.heapsize "$((heapSize))m"
sendToLog "heapSize=$((heapSize))m";

# This is the heap size that is assigned to standard Apps.
# This should typically be no more than half the dalvik.vm.heapsize value.
setprop dalvik.vm.heapgrowthlimit "$((heapGrowthLimit))m"
sendToLog "heapgrowthlimit=$((heapGrowthLimit))m";

# Forces the free memory to never be larger than the given value.
setprop dalvik.vm.heapmaxfree 8m
sendToLog "heapmaxfree=8m";

# Forces the free memory to never be smaller than the given value.
setprop dalvik.vm.heapminfree 2m
sendToLog "heapminfree=2m";

sendToLog "Heap optimization for $((memTotal))mb device activated";
sendToLog "$divider";
}

#
# Profile presets
#
setDefaultProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "0"
	write "$USER_PROFILE"/governor_tuner "0"

	# Entropy section
	write "$USER_PROFILE"/entropy "0"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "0"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"
	
	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "-1"
	write "$USER_PROFILE"/io_blocks_optimization "0"
	write "$USER_PROFILE"/io_extended_queue "0"
	write "$USER_PROFILE"/scheduler_tuner "0"
	write "$USER_PROFILE"/sd_tweak "0"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "0"
	write "$USER_PROFILE"/net_tcp "0"
	write "$USER_PROFILE"/optimize_ril "0"

	# Other
	write "$USER_PROFILE"/disable_debugging "0"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "2"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "3"
	write "$USER_PROFILE"/virtual_memory "0"
	write "$USER_PROFILE"/heap_optimization "0"
}

setPowerSavingProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "1"
	write "$USER_PROFILE"/governor_tuner "1"

	# Entropy section
	write "$USER_PROFILE"/entropy "0"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "1"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"
	
	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "-1"
	write "$USER_PROFILE"/io_blocks_optimization "1"
	write "$USER_PROFILE"/io_extended_queue "0"
	write "$USER_PROFILE"/scheduler_tuner "1"
	write "$USER_PROFILE"/sd_tweak "0"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "0"
	write "$USER_PROFILE"/net_tcp "0"
	write "$USER_PROFILE"/optimize_ril "0"

	# Other
	write "$USER_PROFILE"/disable_debugging "0"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "2"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "1"
	write "$USER_PROFILE"/virtual_memory "1"
	write "$USER_PROFILE"/heap_optimization "0"
}

setBalancedProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "2"
	write "$USER_PROFILE"/governor_tuner "2"

	# Entropy section
	write "$USER_PROFILE"/entropy "0"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "2"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"

	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "-1"
	write "$USER_PROFILE"/io_blocks_optimization "2"
	write "$USER_PROFILE"/io_extended_queue "0"
	write "$USER_PROFILE"/scheduler_tuner "1"
	write "$USER_PROFILE"/sd_tweak "0"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "0"
	write "$USER_PROFILE"/net_tcp "1"
	write "$USER_PROFILE"/optimize_ril "1"

	# Other
	write "$USER_PROFILE"/disable_debugging "0"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "2"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "3"
	write "$USER_PROFILE"/virtual_memory "2"
	write "$USER_PROFILE"/heap_optimization "0"
}

setPerformanceProfile() {
	write "$USER_PROFILE"/battery_improvements "1"
	write "$USER_PROFILE"/doze_optimization "1"

	# CPU section
	write "$USER_PROFILE"/cpu_optimization "3"
	write "$USER_PROFILE"/governor_tuner "3"

	# Entropy section
	write "$USER_PROFILE"/entropy "0"

	# GPU section
	write "$USER_PROFILE"/gpu_optimizer "3"
	write "$USER_PROFILE"/optimize_buffers "0"
	write "$USER_PROFILE"/render_opengles_using_gpu "0"
	write "$USER_PROFILE"/use_opengl_skia "0"
	write "$USER_PROFILE"/force_gpu_rendering "0"
	write "$USER_PROFILE"/force_4x_msaa "0"

	# I/O tweaks section
	write "$USER_PROFILE"/disable_io_stats "-1"
	write "$USER_PROFILE"/io_blocks_optimization "3"
	write "$USER_PROFILE"/io_extended_queue "1"
	write "$USER_PROFILE"/scheduler_tuner "1"
	write "$USER_PROFILE"/sd_tweak "0"

	# LNET tweaks section
	write "$USER_PROFILE"/dns "0"
	write "$USER_PROFILE"/net_buffers "0"
	write "$USER_PROFILE"/net_speed_plus "1"
	write "$USER_PROFILE"/net_tcp "1"
	write "$USER_PROFILE"/optimize_ril "1"

	# Other
	write "$USER_PROFILE"/disable_debugging "0"
	write "$USER_PROFILE"/disable_kernel_panic "0"

	# RAM manager section
	write "$USER_PROFILE"/ram_manager "3"
	write "$USER_PROFILE"/disable_multitasking_limitations "0"
	write "$USER_PROFILE"/low_ram_flag "-1"
	write "$USER_PROFILE"/oom_killer "-1"
	write "$USER_PROFILE"/swappiness "1"
	write "$USER_PROFILE"/virtual_memory "3"
	write "$USER_PROFILE"/heap_optimization "0"
}

# Check number of arguments and perform task based on it.
if [ "$#" -eq 2 ]; then
	$BUSYBOX sleep 0.5;
	"$1" "$2";
	
	exit 0;
elif [ "$#" -eq 1 ]; then
	$BUSYBOX sleep 0.5;
	"$1"
	
	exit 0;
else
sendToLog "Starting L Speed";

# Wait for boot completed and then continue with execution, when getprop sys.boot_completed is	
# equal to 1 while loop will be passed	
attempts=40	
wait=5 # Time in seconds	
bootCompleted=false	
while [ "$attempts" -gt 0 ] && [ "$(getprop sys.boot_completed)" != "1" ]; do	
   sendToLog "Waiting for boot_completed"	
   $BUSYBOX sleep $wait	
   bootCompleted=true	
   attempts=$((attempts-1))	
done	

if [ "$bootCompleted" = true ]; then	
	sendToLog "Waiting for 1min 30secs before applying"	
	$BUSYBOX sleep 90;	
fi

# Read current profile
currentProfile=$($BUSYBOX cat "$PROFILE" 2>/dev/null);
sendToLog "Getting profile...";

if [ "$currentProfile" = "-1" ]; then
	profile="user defined";

elif [ "$currentProfile" = "0" ]; then
	profile="default";
	setDefaultProfile;

elif [ "$currentProfile" = "1" ]; then
	profile="power saving";
	setPowerSavingProfile;

elif [ "$currentProfile" = "2" ]; then
	profile="balanced";
	setBalancedProfile;

elif [ "$currentProfile" = "3" ]; then
	profile="performance";
	setPerformanceProfile;
else
	profile="default";
	setDefaultProfile;
fi
sendToLog "Current profile is $profile";

sendToLog "Applying $profile profile";
sendToLog "$divider";

# Time in seconds when starting with profile applying
# This will be later used for the time difference
start=$($BUSYBOX date +%s)

if [ "$($BUSYBOX cat "$USER_PROFILE"/battery_improvements)" -eq 1 ]; then
	batteryImprovements;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/doze_optimization)" -eq 1 ]; then
	dozeOptimization 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/doze_optimization)" -eq 0 ]; then
	dozeOptimization 0;
fi

#
# CPU tuner section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/cpu_optimization)" -eq 1 ]; then
	cpuOptimizationBattery;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/cpu_optimization)" -eq 2 ]; then
	cpuOptimizationBalanced;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/cpu_optimization)" -eq 3 ]; then
	cpuOptimizationPerformance;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/governor_tuner)" -eq 1 ]; then
	governorTuner 1
elif [ "$($BUSYBOX cat "$USER_PROFILE"/governor_tuner)" -eq 2 ]; then
	governorTuner 2
elif [ "$($BUSYBOX cat "$USER_PROFILE"/governor_tuner)" -eq 3 ]; then
	governorTuner 3
fi

#
# Entropy section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 1 ]; then
	entropyLight;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 2 ]; then
	entropyEnlarger;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 3 ]; then
	entropyModerate;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/entropy)" -eq 4 ]; then
	entropyAggressive;
fi

#
# GPU section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/gpu_optimizer)" -eq 1 ]; then
	gpuOptimizerPowerSaving;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/gpu_optimizer)" -eq 2 ]; then
	gpuOptimizerBalanced;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/gpu_optimizer)" -eq 3 ]; then
	gpuOptimizerPerformance;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/optimize_buffers)" -eq 1 ]; then
	optimizeBuffers;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/render_opengles_using_gpu)" -eq 1 ]; then
	renderOpenglesUsingGpu;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/use_opengl_skia)" -eq 1 ]; then
	useOpenglSkia;
fi

#
# I/O tweaks section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_io_stats)" -eq 0 ]; then
	enableIoStats;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/disable_io_stats)" -eq 1 ]; then
	disableIoStats;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/io_blocks_optimization)" -eq 1 ]; then
	ioBlocksOptimizationPowerSaving;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/io_blocks_optimization)" -eq 2 ]; then
	ioBlocksOptimizationBalanced;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/io_blocks_optimization)" -eq 3 ]; then
	ioBlocksOptimizationPerformance;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/io_extended_queue)" -eq 1 ]; then
	ioExtendedQueue;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/scheduler_tuner)" -eq 1 ]; then
	schedulerTuner;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/sd_tweak)" -eq 1 ]; then
	sdTweak;
fi

#
# LNET tweaks section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/dns)" -eq 1 ]; then
	dnsOptimizationGooglePublic;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/dns)" -eq 2 ]; then
	dnsOptimizationCloudFlare;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/net_buffers)" -eq 1 ]; then
	netBuffersSmall;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/net_buffers)" -eq 2 ]; then
	netBuffersBig;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/net_speed_plus)" -eq 1 ]; then
	netSpeedPlus;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/net_tcp)" -eq 1 ]; then
	netTcpTweaks;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/optimize_ril)" -eq 1 ]; then
	rilTweaks;
fi

#
# Misc
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_debugging)" -eq 1 ]; then
	disableDebugging;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_kernel_panic)" -eq 1 ]; then
	disableKernelPanic;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/selinux)" -eq 0 ]; then
	selinux 0;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/selinux)" -eq 1 ]; then
	selinux 1;
fi

#
# RAM manager section
#
if [ "$($BUSYBOX cat "$USER_PROFILE"/ram_manager)" -eq 1 ]; then
	ramManagerMultitasking;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/ram_manager)" -eq 2 ]; then
	ramManagerBalanced;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/ram_manager)" -eq 3 ]; then
	ramManagerGaming;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/disable_multitasking_limitations)" -eq 1 ]; then
	disableMultitaskingLimitations;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/low_ram_flag)" -eq 0 ]; then
	lowRamFlagDisabled;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/low_ram_flag)" -eq 1 ]; then
	lowRamFlagEnabled;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/oom_killer)" -eq 0 ]; then
	oomKillerDisabled;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/oom_killer)" -eq 1 ]; then
	oomKillerEnabled;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 1 ]; then
	swappinessTendency 1;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 2 ]; then
	swappinessTendency 2;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 3 ]; then
	swappinessTendency 3;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 4 ]; then
	swappinessTendency 4;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 5 ]; then
	swappinessTendency 5;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/swappiness)" -eq 6 ]; then
	swappinessTendency 6;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/virtual_memory)" -eq 1 ]; then
	virtualMemoryTweaksBattery;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/virtual_memory)" -eq 2 ]; then
	virtualMemoryTweaksBalanced;
elif [ "$($BUSYBOX cat "$USER_PROFILE"/virtual_memory)" -eq 3 ]; then
	virtualMemoryTweaksPerformance;
fi

if [ "$($BUSYBOX cat "$USER_PROFILE"/heap_optimization)" -eq 1 ]; then
	heapOptimization;
fi

# End time of the script
end=$($BUSYBOX date +%s)

# Calculate how much took to set up L Speed parameters,
# everything is calculated in seconds
runtime=$((end-start))

sendToLog "Applying took $runtime seconds";
sendToLog "Successfully applied $profile profile";
sendToLog "$divider";

exit 0
fi

exit 0
